int arclmCR(struct arclmframe* af);

/*FOR VECTOR CALCURATION*/
double dotproduct(double* vct1, double* vct2, int vsize);
double vectorlength(double* vct, int vsize);
void vectornormalize(double* vct, int vsize);

/*FOR ROTATION CALCURATION*/
double* rotationvct(double** rmtx);
double** rotationmtx(double* rvct);
double** spinmtx(double* rvct);
double** jacobimtx(double* rvct);


double** spinfittermtx(double* eform, int nnod);/*G*/
double** projectionmtx(double* eform, double* edisp, double** G, int nnod);/*P*/
double** blockjacobimtx(double* edisp, double* estress, double** M, int nnod);/*H&M*/

double** assemtmtx(double** estiff, double* eform, double* edisp, double* estress, double** T, int nnod);
void symmetricmtx(double** estiff, int msize);

void updaterotation(double* ddisp, double* gvct, int nnode);
//void updateforce(double* pvct, double* ddisp, int nnode);

double* extractlocalcoord(double* gdisp, double** drccos, double nnod);
double* extractshelldisplacement(struct oshell shell, double* ddisp);
//double* extractshelllocalcoord(struct oshell shell, double* gdisp);
void extractdeformation(double* eform, double* edisp, int nnod);

void initialformCR(struct onode* nodes, double* ddisp, int nnode);
void LDLmode(struct gcomponent* gmtx, struct oconf* confs, long int* m, int nmode, double** mode, double* norm, double* dm, long int msize);
double shellvolume(struct oshell shell, double** drccos, double area);
//double equilibriumcurvature(double* weight, double* ddisp, double* lastddisp, double loadfactor, double lastloadfactor, double* dup, int msize);
double equilibriumcurvature(double* weight, double* lapddisp, double laploadfactor, double* dup, int msize);

/*
PINPOINTMODE
0:DO NOT DETECT BUCKLING
1:CALCULATE EIGEN VECTOR
*/



int arclmCR(struct arclmframe* af)
{
	DWORDLONG memory;
	char dir[]=DIRECTORY;
	FILE *fdata, *fin, *fonl, * fdsp, * fexf, * finf, * fubf, * fstr, * fene, * ffig, * fbcl, * feig;         /*FILE 8 BYTES*/
	char s[80], string[400], inpname[50], fname[50];

	int i, ii, jj;
	int nnode, nelem, nshell, nsect, nreact, nconstraint;
	int nlap, laps;

	long int msize, nline;
	double time;



	/*FOR READING ANALYSISDATA*/
	int nstr, pstr, readflag, node;
	char **data, *filename;
	int fnode=NULL,fnodedrc=NULL;
	double fnodemin, fnodemax;
	int outputmode = 0;/*0:ConvergedLaps.1:AllLaps.*/
	int pinpointmode = 0;/*0:NotPinpointing.1:BisecPinpointing.2:ExtendedSystemPinpointing.*/
	double arclength, *weight;

	/***GLOBAL MATRIX***/
	struct gcomponent ginit = { 0,0,0.0,NULL };
	struct gcomponent* gmtx, * g, * p, * gcomp1;/*GLOBAL MATRIX*/
	double gg;
	/***GLOBAL VECTOR*/
	double* ddisp, * iform;
	double* u, * ud, * udd, * du, * dud, * dudd;


	double* mvct; /*LUMPED MASS*/
	double* funbalance, * fexternal, * finternal, * fpressure, * fswitching;
	double* due, * dup, * lastdue;
	double* gvct;
	double* vel, * lastvel, * nextvel;
	double* acc;
	double acceleration, velosity;


	/***FOR SHELL ELEMENT***/
	double* gdisp, * edisp;                     /*DEFORMED COORDINATION OF ELEMENT*/
	double* gform, * eform;                      /*INITIAL COORDINATION OF ELEMENT*/
	double* ginternal, * einternal;                        /*INTERNAL FORCE OF ELEMENT*/
	double* gexternal, * eexternal;                          /*EXTERNAL FORCE OF ELEMENT*/
	double* gpressure, * epressure;                          /*EXTERNAL FORCE OF ELEMENT*/
	double* shellstress;                        /*ƒÐx,ƒÐy,ƒÑxy,Mx,My,Mxy OF ELEMENT*/
	double Ep, Eb, Ee;                           /*STRAIN ENERGY OF ELEMENT*/
	double lastlastEk = 0.0;
	double lastEk = 0.0;
	double Ek = 0.0;
	double nextEk = 0.0;                                          /*KINETIC ENERGY*/
	double q = 0.0;
	double** Me,** Ke,** Kt,** DBe,** drccos,** drccosinit,** T, ** Tt;                           /*MATRIX*/
	int* loffset;
	double area;
	/***FOR ARC-LENGTH INCREMENTAL***/
	int iteration;
	int maxiteration = 20;
	int maxtime = 20;
	double ddt = 1.0E-8;
	double residual;
	double tolerance = 1.0e-8;

	double determinant, sign;
	double arcsum, predictorsign;
	double lambda, loadfactor = 0.0;
	double gamma;
	double dupdue, dupdup;
	double volume, masstotal, massdiag;
	/*ARCLENGTH CONTROL*/
	double k1, k, scaledarclength;
	/***FOR BISECSYLVESTER & EXTENDED SYSTEM***/
	double biseceps = 1e-5;
	double gradeps = 1e-8;
	double LL;
	double LR;
	double LM;
	/*FOR BUCKLING DETECTION*/
	double lastsign;
	double* lastpivot;
	double nextloadfactor;
	double lastloadfactor, lastlambda, bisecloadfactor, biseclambda;
	double* lastddisp, * lastgvct, * bisecddisp, * bisecgvct;

	double laploadfactor;
	double* lapddisp;
	double* nextddisp;

	double* epsddisp, * epsgvct, * epsfunbalance, * epsfinternal, * epsfexternal, * epsfpressure, * re, * rp;

	int nmode = 0;
	//double* eigen;/*EIGEN VALUE*/
	//double** evct;/*NORMALIZED EIGEN MODE*/
	double eigen, lasteigen;
	double* lastevct, * evct;
	int inverseiter;
	double eps;

	double evctdot, len, evctlastevct, evctevct, evctfunbalance, epsevctfunbalance;



	double* norm, * dm;/*NORM & PIVOT OF LDL-MODE*/
	int* m;/*LINE OF LDL-MODE*/


	int BCLFLAG = 0;/*FLAG FOR BUCKLING DETECTION*/
	int ENDFLAG = 0;/*FLAG FOR ANLYSIS TERMINATION*/
	int PEAKFLAG = 0;/*FLAG FOR VELOSITY RESET*/
	int DRFLAG = 0;/*FLAG FOR DYNAMIC RELAXARION*/

	int SCALINGARCFLAG = 0;

	int BIGININGARCFLAG = 0;
	double biginingarcratio = 1.0;
	int biginingarclap = 0;



	clock_t t0;

	struct osect* sects;
	struct onode* nodes;
	struct onode* ninit;
	struct owire elem;
	struct owire* elems;
	struct oshell shell;
	struct oshell* shells;
	struct oconf* confs;
	struct memoryelem* melem;
	struct memoryshell* mshell;
	long int mainoff;
	long int* constraintmain;



	fdata = fgetstofopenII(dir, "r", "analysisdata.txt");
	if (fdata == NULL)
	{
		printf("couldn't open analysisdata.txt\n");
		getchar();
		exit(EXIT_FAILURE);
	}
	readflag = 1;
	while (readflag)
	{
		data = fgetsbrk(fdata, &nstr);
		if (nstr == 0)
		{
			readflag = 0;
		}
		else
		{
			pstr = 0; /*POSITION IN "DATA".*/
			while ((nstr - pstr) > 0)
			{
				if (nstr - pstr == 1) /*POINTING LAST STRING.*/
				{
					pstr++;
				}
				else
				{
					if (!strcmp(*(data + pstr), "FILENAME"))
					{
						pstr++;
						filename = *(data + pstr);
					}
					if (!strcmp(*(data + pstr), "LAPS"))
					{
						pstr++;
						laps = (int)strtol(*(data + pstr), NULL, 10);
					}
					if (!strcmp(*(data + pstr), "ITERMAX"))
					{
						pstr++;
						maxiteration = (int)strtol(*(data + pstr), NULL, 10);
					}
					if (!strcmp(*(data + pstr), "ARCLENGTH"))
					{
						pstr++;
						arclength = (double)strtod(*(data + pstr), NULL);
					}
					if (!strcmp(*(data + pstr), "SCALINGARC"))
					{
						SCALINGARCFLAG==1;
					}
					if (!strcmp(*(data + pstr), "BIGININGARC"))
					{
						BIGININGARCFLAG==1;
						pstr++;
						biginingarcratio = (double)strtod(*(data + pstr), NULL);
						pstr++;
						biginingarclap = (int)strtol(*(data + pstr), NULL, 10);
					}
					if (!strcmp(*(data + pstr), "NNODE"))
					{
						pstr++;
						nnode = (int)strtol(*(data + pstr), NULL, 10);
						weight = (double *)malloc((6 * nnode + 1) * sizeof(double));
						for (i = 0;i < 6 * nnode;i++ )
						{
							*(weight + i) = 0.0;
						}
						*(weight + 6 * nnode) = 0.0;
					}
					if (!strcmp(*(data + pstr), "WEIGHT"))
					{
						pstr++;
						if (!strcmp(*(data + pstr), "LOAD"))
						{
							pstr++;
							*(weight + 6 * nnode) = (double)strtod(*(data + pstr), NULL);
						}
						if (!strcmp(*(data + pstr), "NODE"))
						{
							pstr++;
							node= (int)strtol(*(data + pstr), NULL, 10);
							node -= 101;
							pstr++;
							i = (int)strtol(*(data + pstr), NULL, 10);
							pstr++;
							*(weight+6*node+i) = (double)strtod(*(data + pstr), NULL);
						}
					}
					if (!strcmp(*(data + pstr), "OUTPUTMODE"))
					{
						pstr++;
						outputmode = (int)strtol(*(data + pstr), NULL, 10);
					}
					if (!strcmp(*(data + pstr), "PINPOINTMODE"))
					{
						pstr++;
						pinpointmode = (int)strtol(*(data + pstr), NULL, 10);
					}
					if (!strcmp(*(data + pstr), "FNODE"))
					{
						pstr++;
						fnode = (int)strtol(*(data + pstr), NULL, 10);
						pstr++;
						fnodedrc = (int)strtol(*(data + pstr), NULL, 10);
						pstr++;
						fnodemin = (double)strtod(*(data + pstr), NULL);
						pstr++;
						fnodemax = (double)strtod(*(data + pstr), NULL);

					}
					if (!strcmp(*(data + pstr), "LOADFACTOR"))
					{
						pstr++;
						loadfactor = (double)strtod(*(data + pstr), NULL);
					}
					else
					{
						pstr++;
					}
				}
			}
		}
	}



	sprintf(string, "FILENAME:%s\n LAPS = %d\n MAX ITERATION= %d\n ARCLENGTH = %lf\n", filename, laps, maxiteration, arclength);
	errormessage(string);
	if (outputmode == 0)printf("OUTPUT CONVERGED RESULT\n");
	if (outputmode == 1)printf("OUTPUT ALL RESULT\n");

	strcat(filename,".inl");




	sprintf(string, "INITIAL:");
	memory = availablephysicalmemoryEx(string);   /*MEMORY AVAILABLE*/

	fin = fgetstofopenII(dir, "r", filename);              /*OPEN INPUT FILE*/

	strcpy(inpname, filename);
	char* dot = strrchr(inpname, '.');
	*dot = '\0';
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "dsp");
	fdsp = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "inf");
	finf = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "exf");
	fexf = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "ubf");
	fubf = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "str");
	fstr = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "onl");
	fonl = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "fig");
	ffig = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "bcl");
	fbcl = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "ene");
	fene = fopen(fname, "w");
	snprintf(fname, sizeof(fname), "%s.%s", inpname, "eig");
	feig = fopen(fname, "w");



	t0 = clock();                                                   /*CLOCK BEGIN.*/

	inputinitII(fin, &nnode, &nelem, &nshell, &nsect, &nconstraint); /*INPUT INITIAL.*/

	msize = 6 * nnode;                                      /*SIZE OF GLOBAL MATRIX.*/

	sects = (struct osect*)malloc(nsect * sizeof(struct osect));
	nodes = (struct onode*)malloc(nnode * sizeof(struct onode));
	ninit = (struct onode*)malloc(nnode * sizeof(struct onode));
	elems = (struct owire*)malloc(nelem * sizeof(struct owire));
	shells = (struct oshell*)malloc(nshell * sizeof(struct oshell));
	confs = (struct oconf*)malloc(msize * sizeof(struct oconf));

	iform = (double*)malloc(msize * sizeof(double));          /*INITIAL GLOBAL VECTOR.*/
	ddisp = (double*)malloc(msize * sizeof(double));
	melem = (struct memoryelem*)malloc(nelem * sizeof(struct memoryelem));
	mshell = (struct memoryshell*)malloc(nshell * sizeof(struct memoryshell));
	constraintmain = (long int*)malloc(msize * sizeof(long int));


	af->sects = sects;
	af->nodes = nodes;
	af->ninit = ninit;
	af->elems = elems;
	af->shells = shells;
	af->confs = confs;
	af->ddisp = ddisp;
	af->melem = melem;
	af->mshell = mshell;
	af->constraintmain = constraintmain;

	gmtx = (struct gcomponent*)malloc(msize * sizeof(struct gcomponent));
	/*DIAGONALS OF GLOBAL MATRIX.*/

	/*for dynamic*/
	acc = (double*)malloc(msize * sizeof(double));
	vel = (double*)malloc(msize * sizeof(double));
	lastvel = (double*)malloc(msize * sizeof(double));
	nextvel = (double*)malloc(msize * sizeof(double));
	gvct = (double*)malloc(msize * sizeof(double));/*INCREMENTAL GLOBAL VECTOR.*/
	mvct = (double*)malloc(msize * sizeof(double));/*MASS VECTOR.*/


	funbalance = (double*)malloc(msize * sizeof(double));           /*UNBALANCED INTERNAL FORCE VECTOR.*/
	fexternal = (double*)malloc(msize * sizeof(double));           /*EXTERNAL FORCE VECTOR.*/
	finternal = (double*)malloc(msize * sizeof(double));          /*INTERNAL FORCE VECTOR.*/
	fpressure = (double*)malloc(msize * sizeof(double));          /*PRESSURE FORCE VECTOR.*/
	fswitching = (double*)malloc(msize * sizeof(double));

	due = (double*)malloc(msize * sizeof(double));
	dup = (double*)malloc(msize * sizeof(double));

	lastddisp = (double*)malloc(msize * sizeof(double));
	lastgvct = (double*)malloc(msize * sizeof(double));
	lastpivot = (double*)malloc(msize * sizeof(double));        /*PIVOT SIGN OF TANGENTIAL STIFFNESS.*/

	lapddisp = (double*)malloc(msize * sizeof(double));		/*INCREMENT IN LAP*/


	evct = (double*)malloc(msize * sizeof(double));
	lastevct = (double*)malloc(msize * sizeof(double));

	nextddisp = (double*)malloc(msize * sizeof(double));

	bisecddisp = (double*)malloc(6 * nnode * sizeof(double));
	bisecgvct = (double*)malloc(6 * nnode * sizeof(double));

	epsddisp = (double*)malloc(6 * nnode * sizeof(double));
	epsgvct = (double*)malloc(6 * nnode * sizeof(double));
	epsfunbalance = (double*)malloc(6 * nnode * sizeof(double));
	epsfinternal = (double*)malloc(6 * nnode * sizeof(double));
	epsfexternal = (double*)malloc(6 * nnode * sizeof(double));
	epsfpressure = (double*)malloc(6 * nnode * sizeof(double));
	re = (double*)malloc(msize * sizeof(double));
	rp = (double*)malloc(msize * sizeof(double));

	for (i = 0; i < msize; i++)
	{
		(gmtx + i)->down = NULL;
		*(acc + i) = 0.0;
		*(vel + i) = 0.0;
		*(lastvel + i) = 0.0;
		*(nextvel + i) = 0.0;
		*(gvct + i) = 0.0;
		*(constraintmain + i) = i;
	}

	inputtexttomemory(fin, af);
	fclose(fin);

	nnode = af->nnode;
	ninit = af->ninit;
	nelem = af->nelem;
	nshell = af->nshell;
	nsect = af->nsect;
	nreact = af->nreact;
	nconstraint = af->nconstraint;

	initialformCR(nodes, ddisp, nnode);           /*ASSEMBLAGE FORMATION.*/
	initialformCR(ninit, iform, nnode);           /*ASSEMBLAGE FORMATION.*/
	initialelem(elems, melem, nelem);             /*ASSEMBLAGE ELEMENTS.*/
	initialshell(shells, mshell, nshell);         /*ASSEMBLAGE ELEMENTS.*/


	for (ii = 0; ii < msize; ii++)
	{
		if (*(constraintmain + ii) != ii)
		{
			(confs + ii)->iconf = (signed char)1;
		}
	}

	setviewpoint((wdraw.childs+0)->hwnd,arc,
						 &((wdraw.childs+1)->vparam));
	setviewparam((wmenu.childs+2)->hwnd,
						 (wdraw.childs+1)->vparam);
	clearwindow(*(wdraw.childs+1));
	drawarclmframe((wdraw.childs+1)->hdcC,
						   (wdraw.childs+1)->vparam,arc,0,ONSCREEN);


	///FOR DRAWING 1///
	GetAsyncKeyState(VK_LBUTTON);                   /*CLEAR KEY LEFT.*/
	GetAsyncKeyState(VK_RBUTTON);                  /*CLEAR KEY RIGHT.*/
	if(globaldrawflag==1)
	{
	  drawglobalaxis((wdraw.childs+1)->hdcC,(wdraw.childs+1)->vparam,0,0,255);                     /*DRAW GLOBAL AXIS.*/
	}
	///FOR DRAWING 1///


	nlap = 1;
	iteration = 1;
	residual = 0.0;

	while (nlap <= laps && ENDFLAG == 0)
	{

		sprintf(string, "LAP: %5ld / %5ld ITERATION: %5ld\n", nlap, laps, iteration);
		af->nlaps = nlap;

		///FOR DRAWING 2///
		setincrement((wmenu.childs+2)->hwnd,laps,nlap,maxiteration,iteration);
		if(iteration==1)clearwindow(*(wdraw.childs+1));
		///FOR DRAWING 2///

		if ((outputmode == 0 && (iteration == 1 || BCLFLAG == 2)) || outputmode == 1)
		{
			fprintf(fdsp, string);
			fprintf(finf, string);
			fprintf(fexf, string);
			fprintf(fubf, string);
			fprintf(fstr, string);
			fprintf(fene, string);
		}

		for (i = 1; i <= msize; i++)/*MATRIX INITIALIZATION.*/
		{
			g = (gmtx + (i - 1))->down;   /*NEXT OF DIAGONAL.*/
			while (g != NULL) 	      /*CLEAR ROW.*/
			{
				p = g;
				g = g->down;
				free(p);
			}

			ginit.m = (unsigned short int)i;
			*(gmtx + (i - 1)) = ginit;

			*(finternal + (i - 1)) = 0.0;			 /*GLOBAL VECTOR INITIALIZATION.*/
			*(fexternal + (i - 1)) = 0.0;
			*(fpressure + (i - 1)) = 0.0;
			*(funbalance + (i - 1)) = 0.0;
		}
		comps = msize; /*INITIAL COMPONENTS=DIAGONALS.*/

		volume = 0.0;

		assemconf(confs,fexternal,1.0,nnode);               /*GLOBAL VECTOR.*/

	#if 0
		/*CR Girder under constructuon*/
		for (i = 1; i <= nelem; i++)
		{
			inputelem(elems,melem,i-1,&elem);
			elem.sect=(elems+i-1)->sect;
			loffset = (int*)malloc(6 * elem.nnod * sizeof(int));
			for (ii = 0; ii < elem.nnod; ii++)
			{
				for (jj = 0; jj < 6; jj++)
				{
					*(loffset + (6 * ii + jj)) = 6 * (elem.node[ii]->loff) + jj;
				}
			}

			for (ii = 0; ii < elem.nnod; ii++)
			{
				inputnode(iform, elem.node[ii]);
			}
			drccosinit = directioncosine(elem.node[0]->d[0],
							 elem.node[0]->d[1],
							 elem.node[0]->d[2],
							 elem.node[1]->d[0],
							 elem.node[1]->d[1],
							 elem.node[1]->d[2],
							 elem.cangle);
			gform = extractdisplacement(shell, iform);                  /*{Xg}*/
			eform = extractlocalcoord(gform,drccos,elem.nnod);



			for (ii = 0; ii < elem.nnod; ii++)
			{
				inputnode(ddisp, elem.node[ii]);
			}
			drccos = middrccos()
			gdisp = extractdisplacement(shell, ddisp);              /*{Xg+Ug}*/
			edisp = extractlocalcoord(gform,drccos,elem.nnod);

			extractdeformation(eform, edisp, elem.nnod);                /*{Ue}*/

			T = transmatrixIII(drccos, elem.nnod); /*TRANSFORMATION MATRIX[T].*/
			Tt = matrixtranspose(T, 6 * elem.nnod);                    /*[Tt].*/

			Ke = assememtx(elem);                  /*ELASTIC MATRIX OF GIRDER[Ke].*/
			einternal = matrixvector(Ke, edisp, 6 * elem.nnod);      /*ELEMENT INTERNAL FORCE{Fe}=[Ke]{Ue}.*/


			if ((outputmode == 0 && (iteration == 1 || BCLFLAG == 2)) || outputmode == 1)
			{
				Ee = 0.0;                                                                     -
				for (ii = 0; ii < elem.nnod; ii++)                   /*UPDATE STRAIN ENERGY.*/
				{
					for (jj = 0; jj < 6; jj++)
					{
						Ee += 0.5 * *(edisp + 6 * ii + jj) * *(einternal + 6 * ii + jj);
					}
				}
				fprintf(fene, "%5ld %e\n", elem.code, Ee);
			}

			//if (DRFLAG)
			//{
			//	Me = assemmmtx(elem, drccos);              /*MASS MATRIX OF GIRDER[M].*/
			//	Me = transformationIII(Me, T, 6 * elem.nnod);
			//	masstotal = 0.0;
			//	massdiag = 0.0;
			//	for (ii = 0; ii < 12; ii++)
			//	{
			//		for (jj = 0; jj < 12; jj++)
			//		{
			//			masstotal += Me[ii][jj];
			//			if (ii == jj && ii % 6 < 3)massdiag += Me[ii][jj];
			//		}
			//	}
			//	for (ii = 0; ii < elem.nnod; ii++)
			//	{
			//		for (jj = 0; jj < 6; jj++)
			//		{
			//			*(mvct + *(loffset + (6 * ii + jj))) += *(*(Me + 6 * ii + jj) + 6 * ii + jj) * masstotal / massdiag;
			//		}
			//	}
			//	freematrix(Me, 12);
			//}


			Kt = assemtmtx(Ke, eform, edisp, einternal, T, elem.nnod);	  /*TANGENTIAL MATRIX[Kt].*//*PROJECTION of einternal[Pt][Ht]{Fe}.*/

			Kt = transformationIII(Kt, T, 6 * elem.nnod);
			symmetricmtx(Kt, 6 * elem.nnod);      /*SYMMETRIC TANGENTIAL MATRIX[Ksym].*/

			/*assemgstiffness(gmtx,Kt,&elem);*/
			assemgstiffnessIIwithDOFelimination(gmtx, Kt, &elem, constraintmain);/*ASSEMBLAGE TANGENTIAL STIFFNESS MATRIX.*/
			freematrix(Kt, 6 * elem.nnod);

			ginternal = matrixvector(Tt, einternal, 6 * elem.nnod);  /*FROM PROJECTED LOCAL INTERNAL FORCE{PtHtFe} TO GLOBAL INTERNAL FORCE{Fg}.*/
			for (ii = 0; ii < elem.nnod; ii++)
			{
				for (jj = 0; jj < 6; jj++)
				{
					*(finternal + *(loffset + (6 * ii + jj))) += *(ginternal + 6 * ii + jj);
				}
			}

			freematrix(drccosinit, 3);
			freematrix(drccos, 3);
			freematrix(T, 6 * elem.nnod);
			freematrix(Tt, 6 * elem.nnod);
			freematrix(Ke, 6 * elem.nnod);

			free(einternal);
			free(ginternal);

			free(eform);
			free(gform);
			free(edisp);
			free(gdisp);
			free(loffset);

			///FOR DRAWING 3///
			if(iteration==1 && (wdraw.childs+1)->hdcC!=NULL)
			{
			  drawglobalwire((wdraw.childs+1)->hdcC,
							 (wdraw.childs+1)->vparam,
							  *af,elem,255,255,255,
									   255,255,255,0,ONSCREEN);
			}

			///FOR DRAWING 3///
		}
		/*under constructuon*/
# endif

		for (i = 1; i <= nshell; i++)
		{
			inputshell(shells, mshell, i - 1, &shell);
			shell.sect = (shells + i - 1)->sect;                      /*READ SECTION DATA.*/
			loffset = (int*)malloc(6 * shell.nnod * sizeof(int));
			for (ii = 0; ii < shell.nnod; ii++)
			{
				for (jj = 0; jj < 6; jj++)
				{
					*(loffset + (6 * ii + jj)) = 6 * (shell.node[ii]->loff) + jj;
				}
			}

			for (ii = 0; ii < shell.nnod; ii++)
			{
				inputnode(iform, shell.node[ii]);
			}
			drccosinit = shelldrccos(shell, &area);
			gform = extractshelldisplacement(shell, iform);                     /*{Xg}*/
			//eform = extractshelllocalcoord(shell, gform);                     /*{Xe}*/
			eform = extractlocalcoord(gform,drccosinit,shell.nnod);

			for (ii = 0; ii < shell.nnod; ii++)
			{
				inputnode(ddisp, shell.node[ii]);
			}
			drccos = shelldrccos(shell, &area);
			gdisp = extractshelldisplacement(shell, ddisp);                     /*{Xg+Ug}*/
			//edisp = extractshelllocalcoord(shell, gdisp);                     /*{Xe+Ue}*/
			edisp = extractlocalcoord(gdisp,drccos,shell.nnod);

			extractdeformation(eform, edisp, shell.nnod);                       /*{Ue}*/

			volume += shellvolume(shell, drccos, area);                   /*VOLUME*/

			T = transmatrixIII(drccos, shell.nnod);         /*TRANSFORMATION MATRIX[T].*/
			Tt = matrixtranspose(T, 6 * shell.nnod);                  /*[Tt].*/

			if ((outputmode == 0 && (iteration == 1 || BCLFLAG == 2)) || outputmode == 1)
			{
				DBe = (double**)malloc(6 * shell.nnod * sizeof(double*));
				for (ii = 0; ii < 6 * shell.nnod; ii++)
				{
					*(DBe + ii) = (double*)malloc(6 * shell.nnod * sizeof(double));
					for (jj = 0; jj < 6 * shell.nnod; jj++)
					{
						*(*(DBe + ii) + jj) = 0.0;                                          /*INITIAL.*/
					}
				}
			}
			else
			{
				DBe = NULL;
			}

			Ke = assemshellemtx(shell, drccos, DBe);                  /*ELASTIC MATRIX OF SHELL[Ke].*/
			einternal = matrixvector(Ke, edisp, 6 * shell.nnod);      /*ELEMENT INTERNAL FORCE{Fe}=[Ke]{Ue}.*/
			epressure = assemshellpvct(shell, drccos);                /*ELEMENT EXTERNAL FORCE{Pe}.*/

			if ((outputmode == 0 && (iteration == 1 || BCLFLAG == 2)) || outputmode == 1)
			{
				Ee = 0.0;
				Ep = 0.0;
				Eb = 0.0;
				for (ii = 0; ii < shell.nnod; ii++)                   /*UPDATE STRAIN ENERGY.*/
				{
					for (jj = 0; jj < 2; jj++)
					{
						Ep += 0.5 * *(edisp + 6 * ii + jj) * *(einternal + 6 * ii + jj);
					}
					for (jj = 2; jj < 5; jj++)
					{
						Eb += 0.5 * *(edisp + 6 * ii + jj) * *(einternal + 6 * ii + jj);
					}
					Ee += 0.5 * *(edisp + 6 * ii + 5) * *(einternal + 6 * ii + 5);
				}
				Ee += Ep + Eb;
				fprintf(fene, "%5ld %e %e %e\n", shell.code, Ep, Eb, Ee);

				shellstress = matrixvector(DBe, edisp, 6 * shell.nnod);
				for (ii = 0; ii < shell.nnod; ii++)                          /*UPDATE STRESS.*/
				{
					for (jj = 0; jj < 6; jj++)
					{
						shell.stress[ii][jj] = *(shellstress + 6 * ii + jj);
					}
				}
				outputshellstress(shell, shellstress, fstr);
				free(shellstress);
				freematrix(DBe, 6 * shell.nnod);
			}

			//if (DRFLAG)
			//{
			//	Me = assemshellmmtx(shell, drccos);              /*MASS MATRIX OF SHELL[M].*/
			//	Me = transformationIII(Me, T, 6 * shell.nnod);
			//	masstotal = 0.0;
			//	massdiag = 0.0;
			//	for (ii = 0; ii < 18; ii++)
			//	{
			//		for (jj = 0; jj < 18; jj++)
			//		{
			//			masstotal += Me[ii][jj];
			//			if (ii == jj && ii % 6 < 3)massdiag += Me[ii][jj];
			//		}
			//	}
			//	for (ii = 0; ii < shell.nnod; ii++)
			//	{
			//		for (jj = 0; jj < 6; jj++)
			//		{
			//			*(mvct + *(loffset + (6 * ii + jj))) += *(*(Me + 6 * ii + jj) + 6 * ii + jj) * masstotal / massdiag;
			//		}
			//	}
			//	freematrix(Me, 18);
			//}


			Kt = assemtmtx(Ke, eform, edisp, einternal, T, shell.nnod);	  /*TANGENTIAL MATRIX[Kt].*//*PROJECTION of einternal[Pt][Ht]{Fe}.*/

			Kt = transformationIII(Kt, T, 6 * shell.nnod);
			symmetricmtx(Kt, 6 * shell.nnod);      /*SYMMETRIC TANGENTIAL MATRIX[Ksym].*/
			//assemgstiffnessII(gmtx,Kt,&shell);
			assemgstiffnessIIwithDOFelimination(gmtx, Kt, &shell, constraintmain);/*ASSEMBLAGE TANGENTIAL STIFFNESS MATRIX.*/
			freematrix(Kt, 6 * shell.nnod);

			ginternal = matrixvector(Tt, einternal, 6 * shell.nnod);  /*FROM PROJECTED LOCAL INTERNAL FORCE{PtHtFe} TO GLOBAL INTERNAL FORCE{Fg}.*/
			gpressure = matrixvector(Tt, epressure, 6 * shell.nnod);  /*GLOBAL EXTERNAL FORCE{Pg}.*/
			for (ii = 0; ii < shell.nnod; ii++)
			{
				for (jj = 0; jj < 6; jj++)
				{
					*(finternal + *(loffset + (6 * ii + jj))) += *(ginternal + 6 * ii + jj);
					*(fpressure + *(loffset + (6 * ii + jj))) += *(gpressure + 6 * ii + jj);
				}
			}

			freematrix(drccos, 3);
			freematrix(drccosinit, 3);
			freematrix(T, 6 * shell.nnod);
			freematrix(Tt, 6 * shell.nnod);
			freematrix(Ke, 6 * shell.nnod);

			free(einternal);
			free(ginternal);
			free(epressure);
			free(gpressure);

			free(eform);
			free(gform);
			free(edisp);
			free(gdisp);
			free(loffset);

			///FOR DRAWING 3///
			if(iteration==1 && (wdraw.childs+1)->hdcC!=NULL)   /*DRAW DEFORMED ELEMENT.*/
			{
			  drawglobalshell((wdraw.childs+1)->hdcC,
							  (wdraw.childs+1)->vparam,
							  *af,shell,255,255,255,
										255,255,255,0,ONSCREEN/*,i*/);
			}
			///FOR DRAWING 3///
		}

		for (ii = 0; ii < msize; ii++)
		{
			if (*(constraintmain + ii) != ii)
			{
				*(finternal + *(constraintmain + ii)) += *(finternal + ii);
				*(finternal + ii) = 0.0;
				*(fpressure + *(constraintmain + ii)) += *(fpressure + ii);
				*(fpressure + ii) = 0.0;
			}
		}



		///FOR DRAWING 4///
		overlayhdc(*(wdraw.childs+1),SRCPAINT);                  /*UPDATE DISPLAY.*/
		///FOR DRAWING 4///

		residual = 0.0;
		for (i = 0; i < msize; i++)
		{
			*(dup + i) = *(fexternal + i)+*(fpressure + i);
			*(fexternal + i) = loadfactor * *(dup + i);
			*(funbalance + i) = *(fexternal + i) - *(finternal + i);            /*funbalance:UNBALANCED FORCE -{E}.*/
			if ((confs + i)->iconf == 1) *(funbalance + i) = 0.0;
			residual += *(funbalance + i) * *(funbalance + i);
			*(due + i) = *(funbalance + i);
		}
		if ((outputmode == 0 && (iteration == 1 || BCLFLAG == 2)) || outputmode == 1)
		{
			outputdisp(ddisp, fdsp, nnode, nodes);                    /*FORMATION OUTPUT.*/
			outputdisp(finternal, finf, nnode, nodes);                    /*FORMATION OUTPUT.*/
			outputdisp(fexternal, fexf, nnode, nodes);                    /*FORMATION OUTPUT.*/
			outputdisp(funbalance, fubf, nnode, nodes);                    /*FORMATION OUTPUT.*/
		}

		/*if (DRFLAG)
		{
			lastlastEk = lastEk;
			lastEk = nextEk;
			Ek = 0.0;
			nextEk = 0.0;
			acceleration = 0.0;
			velosity = 0.0;

			for (i = 0; i < msize; i++)
			{
				if ((confs + i)->iconf != 1)
				{
					if (time == 0.0 || PEAKFLAG)
					{
						*(nextvel + i) = *(funbalance + i) * ddt / (2.0 * *(mvct + i));
						*(lastvel + i) = -*(nextvel + i);
						*(vel + i) = 0.0;
						*(acc + i) = 2.0 * *(nextvel + i) / ddt;
					}
					else
					{
						*(lastvel + i) = *(nextvel + i);
						*(nextvel + i) = *(funbalance + i) * ddt / (*(mvct + i)) + *(lastvel + i);
						*(vel + i) = (*(nextvel + i) + *(lastvel + i)) / 2.0;
						*(acc + i) = (*(nextvel + i) - *(lastvel + i)) / ddt;
					}
					Ek += 0.5 * *(mvct + i) * *(vel + i) * *(vel + i);
					nextEk += 0.5 * *(mvct + i) * *(nextvel + i) * *(nextvel + i);
					acceleration += *(acc + i) * *(acc + i);
					velosity += *(vel + i) * *(vel + i);

				}
			}
			acceleration = sqrt(acceleration);
			velosity = sqrt(velosity);
			PEAKFLAG = 0;
			if (nextEk < lastEk)
			{
				q = (lastEk - nextEk) / (2 * lastEk - nextEk - lastlastEk);
				for (i = 0; i < msize; i++)
				{
					if ((confs + i)->iconf != 1)
					{
						*(gvct + i) = -q * *(lastvel + i) * ddt;
					}

				}
				lastEk = 0.0;
				nextEk = 0.0;
				PEAKFLAG = 1;
			}
			else
			{
				for (i = 0; i < msize; i++)
				{
					if ((confs + i)->iconf != 1)
					{
						*(gvct + i) = *(nextvel + i) * ddt;
					}
				}
			}

		}*/


		if (BCLFLAG < 1)/*REGULAR*/
		{
			nline = croutlu(gmtx, confs, msize, &determinant, &sign, gcomp1);
			//nmode = 0;
			//for (ii = 0; ii < msize; ii++)
			//{
			//	if ((confs + ii)->iconf == 0 && *(lastpivot + ii) * ((gmtx + ii)->value) < 0)
			//	{
			//		nmode++;
			//	}
			//	if ((confs + ii)->iconf == 0 && ((gmtx + ii)->value) < 0 && iteration==1)
			//	{
			//		errormessage("%d\n ", ii);
			//	}
			//}

			sprintf(string, "LAP: %4d ITER: %2d {LOAD}= % 5.8f {RESD}= %1.6e {DET}= %8.5f {SIGN}= %2.0f {BCL}= %1d {EPS}=%1.5e {V}= %8.5f\n",
				nlap, iteration, loadfactor, residual, determinant, sign, BCLFLAG, 0.0, volume);
			fprintf(ffig, "%s", string);
			errormessage(string);
			/*LDL DECOMPOSITION FAILED*/
			if (sign < 0.0)
			{
				for (ii = 1; ii <= msize; ii++)
				{
					gg = 0.0;
					gread(gmtx, ii, ii, &gg);

					if (gg < 0.0)
					{
						sprintf(string, "INSTABLE TERMINATION AT NODE %ld.",
							(nodes + int((ii - 1) / 6))->code);
						errormessage(" ");
						errormessage(string);
						if (fonl != NULL) fprintf(fonl, "%s\n", string);
					}
				}

				fclose(fin);
				fclose(fonl);
				fclose(fdsp);
				fclose(fexf);
				fclose(finf);
				fclose(fubf);
				fclose(fstr);
				fclose(fene);
				fclose(ffig);
				fclose(fbcl);

				gfree(gmtx, nnode);  /*FREE GLOBAL MATRIX.*/
				free(gvct);
				free(funbalance);
				free(finternal);
				free(fexternal);
				free(due);
				free(dup);
				free(weight);

				return 1;
			}


			if (iteration == 1 && (sign - lastsign) != 0 && nlap != 1 && pinpointmode != 0 && BCLFLAG == 0)
			{
				BCLFLAG = 1;
				sprintf(string, "BUCKLING DITECTED LAP: %4d ITER: %2d  ", nlap, iteration);
				fprintf(fbcl, "%s\n", string);
				//if (pinpointmode == 2)/*EXTENDED SYSTEM*/
				//{
				//	norm = (double *)malloc(nmode * sizeof(double));/*NORM OF LDL MODE*/
				//	dm = (double *)malloc(nmode * sizeof(double));/*DIAGONAL PIVOT VALUE*/
				//	m = (int*)malloc(nmode * sizeof(int));/*BUCKLING DETECTED LINE*/
				//}

				/*jj = 0;
				for (ii = 0; ii < msize; ii++)
				{
					if ((confs + ii)->iconf == 0 && *(lastpivot + ii) * ((gmtx + ii)->value) < 0)
					{
						*(m + jj) = ii;
						jj++;
						sprintf(string, "BUCKLING DITECTED LAP: %4d ITER: %2d LINE: %5ld ", nlap, iteration, ii);
						fprintf(fbcl, "%s\n", string);
						fprintf(feig, "%s", string);
					}
				}*/


				//if(pinpointmode == 1)/*GO TO BISEC*/
				//{
				//	/*NEW TARGET*/
				//	LR = 1.0;
				//	LL = 0.0;
				//	/*NEW TARGET*/
				//	lambda = 0.5 * (LL + LR) * biseclambda;
				//	loadfactor = bisecloadfactor;
				//	for (ii = 0; ii < msize; ii++)
				//	{
				//		*(gvct + ii) = 0.5 * (LL + LR) * *(bisecgvct + ii);
				//		*(ddisp + ii) = *(bisecddisp + ii);
				//	}
				//}
				//else/*GO TO LAST EQUIBRIUM POINT*/
				//{
				//	/*NEW TARGET*/
				//	lambda = 0.0;
				//	loadfactor = lastloadfactor;
				//	for (ii = 0; ii < msize; ii++)
				//	{
				//		*(gvct + ii) = 0.0;
				//		*(ddisp + ii) = *(lastddisp + ii);
				//	}
				//}
				if (pinpointmode == 1)/*GO TO BISEC*/
				{
					/*NEW TARGET*/

					LR = 1.0;
					LL = 0.0;
					LM = 0.5;
					/*NEW TARGET*/
					nextloadfactor = loadfactor;
					loadfactor = 0.5 * (nextloadfactor + lastloadfactor);
					for (ii = 0; ii < msize; ii++)
					{
						*(nextddisp + ii) = *(ddisp + ii);
						*(ddisp + ii) = 0.5 * (*(nextddisp + ii) + *(lastddisp + ii));
					}
				}
				iteration++;
			}
			else
			{
				if (iteration == 1)/*PREDICTOR CALCULATION*/
				{
					nline = forwardbackward(gmtx, dup, confs, msize, gcomp1);
					/*ARCLENGTH CONTROL*/
					if (nlap < biginingarclap+1)
					{
						scaledarclength = biginingarcratio * arclength;
					}
					else if (nlap == biginingarclap+1)
					{
						scaledarclength = arclength;
					}
					else if (nlap == biginingarclap+2)
					{
						if(SCALINGARCFLAG==1)
						{
							k1 = equilibriumcurvature(weight, lapddisp, laploadfactor, dup, msize);
						}
					}
					else
					{
						if(SCALINGARCFLAG==1)
						{
							k = equilibriumcurvature(weight, lapddisp, laploadfactor, dup, msize);
							scaledarclength = arclength * sqrt(k1 / k);
							if (scaledarclength > arclength)scaledarclength = arclength;
						}
					}

					/*SIGN OF PREDICTOR VECTOR & ARC-LENGTH SCALING FACTOR*/
					if (nlap == 1)
					{
						/*for (ii = 0; ii < msize; ii++)
						{
							if ((confs + ii)->iconf == 0 && *(weight + ii) != 0.0)
							{
								if(*(dup + ii)=!0.0)
								{
									*(weight + ii) = 1.0 / abs(*(dup + ii));
								}
								else
								{
									*(weight + ii) = 0.0;
								}
							}
						}*/
                        for (ii = 0; ii < msize; ii++)
						{
							if ((confs + ii)->iconf != 1 && *(weight + ii) != 0.0)
							{
								*(weight + ii) = 1.0 / abs(*(dup + ii));
							}
						}
					}

					if (nlap == 1)
					{
						predictorsign = 1.0;
					}
					else
					{
						predictorsign = *(weight + msize) * *(weight + msize) * laploadfactor * 1.0;
						for (ii = 0; ii < msize; ii++)
						{
							predictorsign += *(weight + ii) * *(weight + ii) * *(lapddisp + ii) * *(dup + ii);
						}
						if(predictorsign != 0.0)
						{
							predictorsign /= abs(predictorsign);
						}
						else
						{
							predictorsign = 1.0;
						}
					}

					/*INCREMENTAL CALCULATION*/
					arcsum = *(weight + msize) * *(weight + msize);
					for (ii = 0; ii < msize; ii++)
					{
						arcsum += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(dup + ii);/*SCALED DISPLACEMENT.*/
					}
					lambda = predictorsign * scaledarclength / sqrt(arcsum);/*INCREMANTAL LOAD FACTOR.*/
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							*(gvct + ii) = lambda * *(dup + ii);/*INCREMANTAL DISPLACEMENT.*/
						}
					}
					fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= % 5.8f {TOP}= % 5.8f {BOTTOM}= % 5.8f\n", nlap, iteration, lambda, scaledarclength, sqrt(arcsum));


					/*MEMORY OF PREDICTOR*/
					for (ii = 0; ii < msize; ii++)
					{
						*(lastddisp + ii) = *(ddisp + ii);/*NODE COORDINATION AT CONVERGED POINT*/
						*(lastgvct + ii) = *(gvct + ii);/*INCREMENTAL DISPLACEMENT OF PREDICTOR*/
						*(lastpivot + ii) = (gmtx + ii)->value;/*PIVOT SIGN OF TANGENTIAL STIFFNESS*/
					}
					lastloadfactor = loadfactor;/*LOAD FACTOR AT CONVERGED POINT*/
					lastlambda = lambda;/*INCREMENTAL LOAD FACTOR OF PREDICTOR*/
					lastsign = sign;/*SIGN AT CONVERGED POINT*/
					BCLFLAG = 0;

				}
				else if (BCLFLAG == -2)/*CORRECTOR CALCULATION*/
				{
					nline = forwardbackward(gmtx, due, confs, msize, gcomp1);
					lambda = 0.0;
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							*(gvct + ii) = *(due + ii);/*gvct:{ƒÂU_e+ƒÂƒ©U_p}*/
						}
					}
					fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= % 5.8f {TOP}= % 5.8f {BOTTOM}= % 5.8f\n", nlap, iteration, lambda, 0.0, 0.0);
				}
				else/*CORRECTOR CALCULATION*/
				{
					nline = forwardbackward(gmtx, dup, confs, msize, gcomp1);
					nline = forwardbackward(gmtx, due, confs, msize, gcomp1);
					/*MINIMUM RESIDUAL QUANTITIES METHOD*/
					dupdue = 0.0;
					dupdup = *(weight + msize) * *(weight + msize);
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							dupdue += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(due + ii);
							dupdup += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(dup + ii);
							//dupdue += *(dup + ii) * *(due + ii);
							//dupdup += *(dup + ii) * *(dup + ii);
						}
					}
					lambda = -dupdue / dupdup;
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							*(gvct + ii) = lambda * *(dup + ii) + *(due + ii);
						}
					}
					/*HYPERSPHERE CONSTRAINT WITH RADIAL RETURN*/
					/*
					dupdue = 0.0;
					dupdup = *(weight + msize) * *(weight + msize) * lambda;
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							dupdue += *(weight + ii) * *(weight + ii) * *(gvct + ii) * *(due + ii);
							dupdup += *(weight + ii) * *(weight + ii) * *(gvct + ii) * *(dup + ii);
						}
					}
					lambda += - dupdue / dupdup;
					fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= %e {TOP}= %e {BOTTOM}= %e\n", nlap, iteration, lambda, dupdue, dupdup);
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							*(gvct + ii) += -(dupdue / dupdup) * *(dup + ii) + *(due + ii);
						}
					}
					arcsum = *(weight + msize) * *(weight + msize) * lambda * lambda;
					for (ii = 0; ii < msize; ii++)
					{
						if ((confs + ii)->iconf != 1)
						{
							arcsum += *(weight + ii) * *(weight + ii) * *(gvct + ii) * *(gvct + ii);
						}
					}
					lambda *= scaledarclength / sqrt(arcsum);
					loadfactor = lastloadfactor;
					for (ii = 0; ii < msize; ii++)
					{
						*(gvct + ii) *= scaledarclength / sqrt(arcsum);
						*(ddisp + ii) = *(lastddisp + ii);
					}
					*/
					fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= % 5.8f {TOP}= % 5.8f {BOTTOM}= % 5.8f\n", nlap, iteration, lambda, dupdue, dupdup);
				}



				for (ii = 0; ii < msize; ii++)
				{
					if (*(constraintmain + ii) != ii)
					{
						mainoff = *(constraintmain + ii);
						*(gvct + ii) = *(gvct + mainoff);
					}
				}

				/*lapddisp : INCREMENTAL TRANSITION & ROTATION IN THIS LAP.*/
				if(iteration==1)
				{
					laploadfactor=0.0;
					for(i=0;i++;i<msize)
					{
						*(lapddisp+i)=0.0;
					}
				}
				laploadfactor += lambda;
				updaterotation(lapddisp, gvct, nnode);

                loadfactor += lambda;
				updaterotation(ddisp, gvct, nnode);



				if ((residual < tolerance || iteration > maxiteration) && iteration != 1)
				{
					nlap++;
					iteration = 0;
				}
				else if (maxiteration == 1)
				{
					nlap++;
					iteration = 0;
				}
				iteration++;

			}
			//if (BCLFLAG == 0)
			//{
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		*(bisecddisp + ii) = *(ddisp + ii);
			//		*(bisecgvct + ii) = *(gvct + ii);
			//	}
			//	bisecloadfactor = loadfactor;
			//	biseclambda = lambda;
			//	
			//}
		}
		else if (BCLFLAG == 1)/*BUCKLING DETECTED.PIN-POINTING EXCUTION.*/
		{
			nline = croutlu(gmtx, confs, msize, &determinant, &sign, gcomp1);/*FOT COUNTING NEGATIVE PIVOT*/
			/*nmode = 0;
			for (ii = 0; ii < msize; ii++)
			{
				if ((confs + ii)->iconf == 0 && *(lastpivot + ii) * ((gmtx + ii)->value) < 0)
				{
					nmode++;
				}
			}*/
			sprintf(string, "LAP: %4d ITER: %2d {LOAD}= % 5.8f {RESD}= %1.6e {DET}= %8.5f {SIGN}= %2.0f {BCL}= %1d {EPS}=%1.5e {V}= %8.5f\n",
				nlap, iteration, loadfactor, residual, determinant, sign, BCLFLAG, LM, volume);
			fprintf(ffig, "%s", string);
			fprintf(fbcl, "%s", string);
			errormessage(string);
			/*LDL DECOMPOSITION FAILED*/
			if (sign < 0.0)
			{
				for (ii = 1; ii <= msize; ii++)
				{
					gg = 0.0;
					gread(gmtx, ii, ii, &gg);

					if (gg < 0.0)
					{
						sprintf(string, "INSTABLE TERMINATION AT NODE %ld.",
							(nodes + int((ii - 1) / 6))->code);
						errormessage(" ");
						errormessage(string);
						if (fonl != NULL) fprintf(fonl, "%s\n", string);
					}
				}

				fclose(fin);
				fclose(fonl);
				fclose(fdsp);
				fclose(fexf);
				fclose(finf);
				fclose(fubf);
				fclose(fstr);
				fclose(fene);
				fclose(ffig);
				fclose(fbcl);

				gfree(gmtx, nnode);  /*FREE GLOBAL MATRIX.*/
				free(gvct);
				free(funbalance);
				free(finternal);
				free(fexternal);
				free(due);
				free(dup);
				free(weight);

				return 1;
			}

			if (pinpointmode == 1)/*PIN-POINTING BASED ON SYLVESTER'S LAW OF INERTIA (BISECTION METHOD).*/
			{
				/*BISECTION PIN-POINTING*/
				if (lastsign == sign)
				{
					LL = LM;
				}
				else
				{
					LR = LM;
				}
				if (LR - LL < biseceps)/*CONVERGED*/
				{
					BCLFLAG = 2;
				}
				LM = 0.5 * (LL + LR);
				loadfactor = (1 - LM) * lastloadfactor + LM * nextloadfactor;
				for (ii = 0; ii < msize; ii++)
				{
					*(ddisp + ii) = (1 - LM) * *(lastddisp + ii) + LM * *(nextddisp + ii);
				}
				iteration++;
			}
			#if 0
			if (pinpointmode == 2)/*PIN-POINTING BASED ON EXTENDED SYSTEM.*/
			{
				nline = forwardbackward(gmtx, dup, confs, msize, gcomp1);
				nline = forwardbackward(gmtx, due, confs, msize, gcomp1);
				/*FOR DIRECTIONAL DERIVATIVE OF TANGENTIAL STIFFNESS MATRIX*/
				LDLmode(gmtx, confs, m, nmode, evct, norm, dm, msize);
				for (i = 0; i < nmode; i++)
				{
					fprintf(fbcl, "CRITICAL EIGEN VECTOR : LINE = %5ld NORM = %12.9f dm = %12.9f\n", *(m + i), *(norm + i), *(dm + i));
					for (ii = 0; ii < nnode; ii++)
					{
						fprintf(fbcl, "%5ld %12.9f %12.9f %12.9f %12.9f %12.9f %12.9f\n", (nodes + ii)->code,
							*(*(evct + i) + (6 * ii + 0)), *(*(evct + i) + (6 * ii + 1)), *(*(evct + i) + (6 * ii + 2)),
							*(*(evct + i) + (6 * ii + 3)), *(*(evct + i) + (6 * ii + 4)), *(*(evct + i) + (6 * ii + 5)));
					}
				}

				for (ii = 0; ii < msize; ii++)/*UPDATE FORM FOR DIRECTIONAL DERIVATIVE*/
				{
					*(epsgvct + ii) = gradeps * *(*(evct + 0) + ii);
					*(epsddisp + ii) = *(ddisp + ii);
				}
				for (ii = 0; ii < msize; ii++)
				{
					if (*(constraintmain + ii) != ii)
					{
						mainoff = *(constraintmain + ii);
						*(epsgvct + ii) = *(gvct + mainoff);
					}
				}
				updaterotation(epsddisp, epsgvct, nnode);

				for (ii = 0; ii < msize; ii++)
				{
					*(re + ii) = 0.0;
					*(rp + ii) = 0.0;
				}
				volume = 0.0;
				for (i = 1; i <= nshell; i++)
				{
					inputshell(shells, mshell, i - 1, &shell);
					shell.sect = (shells + i - 1)->sect;                      /*READ SECTION DATA.*/
					loffset = (int*)malloc(18 * sizeof(int));
					for (ii = 0; ii < shell.nnod; ii++)
					{
						for (jj = 0; jj < 6; jj++)
						{
							*(loffset + (6 * ii + jj)) = 6 * (shell.node[ii]->loff) + jj;
						}
					}

					for (ii = 0; ii < shell.nnod; ii++)
					{
						inputnode(iform, shell.node[ii]);
					}
					drccosinit = shelldrccos(shell, &area);
					gform = extractshelldisplacement(shell, iform);
					//eform = extractshelllocalcoord(shell, gform);
					eform = extractlocalcoord(gform,drccosinit,shell.nnod);

					for (ii = 0; ii < shell.nnod; ii++)
					{
						inputnode(ddisp, shell.node[ii]);
					}
					drccos = shelldrccos(shell, &area);
					gdisp = extractshelldisplacement(shell, ddisp);
					//edisp = extractshelllocalcoord(shell, gdisp);
					edisp = extractlocalcoord(gdisp,drccos,shell.nnod);

					extractdeformation(eform, edisp, shell.nnod);                   /*{Ue}*/

					volume += shellvolume(shell, drccos, area);                    /*VOLUME*/
					T = transmatrixIII(drccos, shell.nnod);     /*TRANSFORMATION MATRIX[T].*/

					Ke = assemshellemtx(shell, drccos, NULL); /*ELASTIC MATRIX OF SHELL[K].*/
					einternal = matrixvector(Ke, edisp, 6 * shell.nnod);
					epressure = assemshellpvct(shell, drccos);/*ELEMENT EXTERNAL FORCE{Fe}.*/

					Kt = assemtmtx(Ke, eform, edisp, einternal, T, shell.nnod);
					Kt = transformationIII(Kt, T, 6 * shell.nnod);
					symmetricmtx(Kt, 6 * shell.nnod);


					for (ii = 0; ii < 18; ii++)
					{
						for (jj = 0; jj < 18; jj++)
						{
							*(re + *(loffset + ii)) += *(*(Kt + ii) + jj) * *(due + *(loffset + jj));
							*(rp + *(loffset + ii)) += *(*(Kt + ii) + jj) * *(dup + *(loffset + jj));
						}
					}

					freematrix(drccosinit, 3);
					freematrix(drccos, 3);
					freematrix(T, 18);
					freematrix(Ke, 18);
					freematrix(Kt, 18);
					free(loffset);
					free(einternal);
					free(epressure);
					free(eform);
					free(gform);
					free(edisp);
					free(gdisp);
				}

			//	for (i = 0; i < msize; i++)/*UPDATE FORM FOR DIRECTIONAL DERIVATIVE*/
			//	{
			//		*(re + i) -= *(funbalance + i);
			//		*(rp + i) -= *(fpressure + i);
			//		if ((confs + i)->iconf != 0)
			//		{
			//			*(re + i) = 0.0;
			//			*(rp + i) = 0.0;
			//		}
			//	}

			//	//fprintf(fbcl, "\"rp:\"\n");
			//	//for (i = 0; i < nnode; i++)
			//	//{
			//	//	fprintf(fbcl, "NODE:%5ld %12.15f %12.15f %12.15f %12.15f %12.15f %12.15f\n", (nodes + i)->code,
			//	//		*(rp + (6 * i + 0)), *(rp + (6 * i + 1)), *(rp + (6 * i + 2)),
			//	//		*(rp + (6 * i + 3)), *(rp + (6 * i + 4)), *(rp + (6 * i + 5)));
			//	//}
			//	//fprintf(fbcl, "\"re:\"\n");
			//	//for (i = 0; i < nnode; i++)
			//	//{
			//	//	fprintf(fbcl, "NODE:%5ld %12.15f %12.15f %12.15f %12.15f %12.15f %12.15f\n", (nodes + i)->code,
			//	//		*(re + (6 * i + 0)), *(re + (6 * i + 1)), *(re + (6 * i + 2)),
			//	//		*(re + (6 * i + 3)), *(re + (6 * i + 4)), *(re + (6 * i + 5)));
			//	//}

			//	/*dupdue=*(dm+0)/(*(norm+0)**(norm+0)); */
			//	fprintf(fbcl, "PIN-POINTED EIGENVALUE=%12.9f\n", dupdue);

			//	/*dupdue*=eps;*/
			//	dupdue = 0;
			//	dupdup = 0;
			//	fprintf(fonl, "dupdue=%12.15f dupdup=%12.15f\n", dupdue, dupdup);
			//	for (i = 0; i < msize; i++)
			//	{
			//		if ((confs + i)->iconf == 0)
			//		{
			//			dupdup += *(rp + i) * *(*(evct + 0) + i);
			//			dupdue += *(re + i) * *(*(evct + 0) + i);
			//		}
			//	}



			//	fprintf(fonl, "dupdue=%12.15f dupdup=%12.15f\n", dupdue, dupdup);
			//	dupdue += gradeps * *(dm + 0) / (*(norm + 0) * *(norm + 0));

			//	lambda = -dupdue / dupdup;
			//	fprintf(fonl, "LAMBDA=%12.9f\n", lambda);




			//	/*NEW TARGET*/
			//	loadfactor += lambda;
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		if ((confs + ii)->iconf != 1)
			//		{
			//			*(gvct + ii) = *(dup + ii) * lambda + *(due + ii);/*gvct:{ƒÂU_e+ƒÂƒ©U_p}*/
			//		}
			//	}
			//	/*PINPOINTING END*/
			//	if (iteration != 1 && fabs(*(dm + 0)) < tolerance)
			//	{
			//		nlap++;
			//		iteration = 0;
			//		nmode = 0;
			//		freematrix(evct, nmode);
			//		free(norm);
			//		free(dm);
			//		free(m);
			//	}
			//	/*FORMATION UPDATE FOR PREDICTOR/CORRECTOR*/
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		if (*(constraintmain + ii) != ii)
			//		{
			//			mainoff = *(constraintmain + ii);
			//			*(gvct + ii) = *(gvct + mainoff);
			//		}
			//	}
			//	updaterotation(ddisp, gvct, nnode);
			//	iteration++;
			}
			#endif
		}
		else if (BCLFLAG == 2)/*CALCULATE EIGEN VECTOR*/
		{
			sprintf(string, "BUCKLING DITECTED LAP: %4d ITER: %2d  ", nlap, iteration);
			fprintf(feig, "%s", string);
			nline = croutlu(gmtx, confs, msize, &determinant, &sign, gcomp1);/*FOT COUNTING NEGATIVE PIVOT*/
			sprintf(string, "LAP: %4d ITER: %2d {LOAD}= % 5.8f {RESD}= %1.6e {DET}= %8.5f {SIGN}= %2.0f {BCL}= %1d {EPS}=%1.5e {V}= %8.5f\n",
				nlap, iteration, loadfactor, residual, determinant, sign, BCLFLAG, LM, volume);
			fprintf(ffig, "%s", string);
			fprintf(fbcl, "%s", string);
			errormessage(string);
			/*LDL DECOMPOSITION FAILED*/
			if (sign < 0.0)
			{
				for (ii = 1; ii <= msize; ii++)
				{
					gg = 0.0;
					gread(gmtx, ii, ii, &gg);

					if (gg < 0.0)
					{
						sprintf(string, "INSTABLE TERMINATION AT NODE %ld.",
							(nodes + int((ii - 1) / 6))->code);
						errormessage(" ");
						errormessage(string);
						fprintf(fonl, "%s\n", string);
					}
				}

				fclose(fin);
				fclose(fonl);
				fclose(fdsp);
				fclose(fexf);
				fclose(finf);
				fclose(fubf);
				fclose(fstr);
				fclose(fene);
				fclose(ffig);
				fclose(fbcl);

				gfree(gmtx, nnode);  /*FREE GLOBAL MATRIX.*/
				free(gvct);
				free(funbalance);
				free(finternal);
				free(fexternal);
				free(fpressure);
				free(due);
				free(dup);
				free(weight);

				return 1;
			}
			/*CALCULATE EIGEN VECTOR*/
			for (ii = 0; ii < msize; ii++)
			{
				*(evct + ii) = *(due + ii);
			}
			vectornormalize(evct, msize);
			vectornormalize(fexternal, msize);
			len = 1.0;
			inverseiter = 0;
			while (len > 1.0e-6 && inverseiter < 20)/*INVERSE METHOD*/
			{
				for (ii = 0; ii < msize; ii++)
				{
					*(lastevct + ii) = *(evct + ii);
				}
				nline = forwardbackward(gmtx, evct, confs, msize, gcomp1);

				evctlastevct = dotproduct(evct, lastevct, msize);
				evctevct = dotproduct(evct, evct, msize);
				eigen = evctlastevct / evctevct;
				vectornormalize(evct, msize);
				for (ii = 0; ii < msize; ii++)
				{
					*(lastevct + ii) = abs(*(lastevct + ii)) - abs(*(evct + ii));
				}
				len = vectorlength(lastevct, msize);
				evctdot = dotproduct(evct, fexternal, msize);/*BIFURCATION JUDGE*/
				sprintf(string, "INVERSE ITERATION : LOADFACTOR= %e EIGENVALUE= %e DOT= %e LEN= %e BIFURCATION= %d\n", loadfactor, eigen, evctdot, len, abs(evctdot) < 1.0e-3);
				fprintf(fbcl, "%s", string);
				inverseiter++;
			}
			fprintf(feig, string);
			errormessage(string);
			for (ii = 0; ii < msize; ii++)
			{
				if (*(constraintmain + ii) != ii)
				{
					mainoff = *(constraintmain + ii);
					*(evct + ii) = *(evct + mainoff);
				}
			}
			for (ii = 0; ii < nnode; ii++)
			{
				fprintf(feig, "%5ld %12.9f %12.9f %12.9f %12.9f %12.9f %12.9f\n", (nodes + ii)->code,
					*(evct + (6 * ii + 0)), *(evct + (6 * ii + 1)), *(evct + (6 * ii + 2)),
					*(evct + (6 * ii + 3)), *(evct + (6 * ii + 4)), *(evct + (6 * ii + 5)));
			}


			if (1)//(abs(evctdot) > 1.0e-3)/*LIMIT POINT*/
			{
				BCLFLAG = -1;
				loadfactor = nextloadfactor;
				for (ii = 0; ii < msize; ii++)
				{
					*(ddisp + ii) = *(nextddisp + ii);
				}
				//nmode = 0;
			}
			else/*BIFURCATION*/
			{
				BCLFLAG = 3;
				loadfactor = lastloadfactor;
				for (ii = 0; ii < msize; ii++)
				{
					*(ddisp + ii) = *(lastddisp + ii);
				}
				eps = 0.0;
				gamma = 0.0;
			}

			iteration++;
		}
		else if (BCLFLAG == 3)
		{
			//residual = 0.0;
			//for (i = 0; i < msize; i++)
			//{
			//	*(dup + i) = *(*(evct + 0) + i);
			//	*(fswitching + i) = gamma * *(*(evct + 0) + i) + *(funbalance + i);
			//	if ((confs + i)->iconf == 1) *(fswitching + i) = 0.0;
			//	residual += *(fswitching + i) * *(fswitching + i);
			//	*(due + i) = *(fswitching + i);
			//}


			///*GLOBALLY CONVERGENT NONLINEAR SOLUTION METHOD*/
			//nline = croutlu(gmtx, confs, msize, &determinant, &sign, gcomp1);

			//sprintf(string, "LAP: %4d ITER: %2d {LOAD}= % 5.8f {RESD}= %1.6e {DET}= %8.5f {SIGN}= %2.0f {BCL}= %1d {EPS}=%1.5e {V}= %8.5f\n",
			//	nlap, iteration, loadfactor, residual, determinant, sign, BCLFLAG, gamma, volume);
			//fprintf(ffig, "%s", string);
			//errormessage(string);


			//if (iteration == 1)/*PREDICTOR CALCULATION*/
			//{
			//	nline = forwardbackward(gmtx, dup, confs, msize, gcomp1);
			//	scaledarclength = 1e-3 * arclength;


			//	/*INCREMENTAL CALCULATION*/
			//	arcsum = *(weight + msize) * *(weight + msize);
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		arcsum += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(dup + ii);/*SCALED DISPLACEMENT.*/
			//	}
			//	lambda = scaledarclength / sqrt(arcsum);/*INCREMANTAL LOAD FACTOR.*/
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		if ((confs + ii)->iconf != 1)
			//		{
			//			*(gvct + ii) = gamma * *(dup + ii);/*INCREMANTAL DISPLACEMENT.*/
			//		}
			//	}
			//	fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= % 5.8f {TOP}= % 5.8f {BOTTOM}= % 5.8f\n", nlap, iteration, lambda, scaledarclength, sqrt(arcsum));
			//}
			//else/*CORRECTOR CALCULATION*/
			//{
			//	nline = forwardbackward(gmtx, dup, confs, msize, gcomp1);
			//	nline = forwardbackward(gmtx, due, confs, msize, gcomp1);
			//	/*MINIMUM RESIDUAL QUANTITIES METHOD*/
			//	dupdue = 0.0;
			//	dupdup = *(weight + msize) * *(weight + msize);
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		if ((confs + ii)->iconf != 1)
			//		{
			//			dupdue += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(due + ii);
			//			dupdup += *(weight + ii) * *(weight + ii) * *(dup + ii) * *(dup + ii);
			//		}
			//	}
			//	lambda = -dupdue / dupdup;
			//	for (ii = 0; ii < msize; ii++)
			//	{
			//		if ((confs + ii)->iconf != 1)
			//		{
			//			*(gvct + ii) = gamma * *(dup + ii) + *(due + ii);
			//		}
			//	}
			//	fprintf(fonl, "LAP: %4d ITER: %2d {LAMBDA}= % 5.8f {TOP}= % 5.8f {BOTTOM}= % 5.8f\n", nlap, iteration, lambda, dupdue, dupdup);
			//}

			//gamma += lambda;
			//for (ii = 0; ii < msize; ii++)
			//{
			//	if (*(constraintmain + ii) != ii)
			//	{
			//		mainoff = *(constraintmain + ii);
			//		*(gvct + ii) = *(gvct + mainoff);
			//	}
			//}
			//updaterotation(ddisp, gvct, nnode);
			//if ((residual < tolerance || iteration > maxiteration) && iteration != 1)
			//{
			//	nlap++;
			//	iteration = 0;
			//}
			//iteration++;

			/*LINE SEARCH*/
			evctfunbalance = dotproduct(evct, funbalance, msize);
			fprintf(fbcl, " %5.8e %5.8e \n", eps, evctfunbalance);


			for (ii = 0; ii < msize; ii++)/*UPDATE FORM FOR DIRECTIONAL DERIVATIVE*/
			{
				*(epsddisp + ii) = *(ddisp + ii);
				*(epsgvct + ii) = gradeps * *(evct + ii);
			}
			for (ii = 0; ii < msize; ii++)
			{
				if (*(constraintmain + ii) != ii)
				{
					mainoff = *(constraintmain + ii);
					*(epsgvct + ii) = *(epsgvct + mainoff);
				}
			}
			updaterotation(epsddisp, epsgvct, nnode);

			for (ii = 0; ii < msize; ii++)
			{
				*(epsfinternal + ii) = 0.0;
				*(epsfpressure + ii) = 0.0;
			}

			for (i = 1; i <= nshell; i++)
			{
				inputshell(shells, mshell, i - 1, &shell);
				shell.sect = (shells + i - 1)->sect;                      /*READ SECTION DATA.*/
				loffset = (int*)malloc(6 * shell.nnod * sizeof(int));
				for (ii = 0; ii < shell.nnod; ii++)
				{
					for (jj = 0; jj < 6; jj++)
					{
						*(loffset + (6 * ii + jj)) = 6 * (shell.node[ii]->loff) + jj;
					}
				}

				for (ii = 0; ii < shell.nnod; ii++)
				{
					inputnode(iform, shell.node[ii]);
				}
				drccosinit = shelldrccos(shell, &area);                                /*DRCCOS*/
				gform = extractshelldisplacement(shell, iform);                      /*{Xg}*/
				//eform = extractshelllocalcoord(shell, gform);                        /*{Xe}*/
				eform = extractlocalcoord(gform,drccosinit,shell.nnod);

				for (ii = 0; ii < shell.nnod; ii++)
				{
					inputnode(epsddisp, shell.node[ii]);
				}
				drccos = shelldrccos(shell, &area);                                /*DRCCOS*/
				gdisp = extractshelldisplacement(shell, epsddisp);                   /*{Xg+Ug}*/
				//edisp = extractshelllocalcoord(shell, gdisp);                     /*{Xe+Ue}*/
				edisp = extractlocalcoord(gdisp,drccos,shell.nnod);

				extractdeformation(eform, edisp, shell.nnod);                       /*{Ue}*/


				volume += shellvolume(shell, drccos, area);                   /*VOLUME*/
				T = transmatrixIII(drccos, shell.nnod);         /*TRANSFORMATION MATRIX[T].*/
				Tt = matrixtranspose(T, 6 * shell.nnod);                              /*[Tt].*/

				Ke = assemshellemtx(shell, drccos, NULL);                  /*ELASTIC MATRIX OF SHELL[Ke].*/
				einternal = matrixvector(Ke, edisp, 6 * shell.nnod);      /*ELEMENT INTERNAL FORCE{Fe}=[Ke]{Ue}.*/
				epressure = assemshellpvct(shell, drccos);                /*ELEMENT EXTERNAL FORCE{Pe}.*/

				Kt = assemtmtx(Ke, eform, edisp, einternal, T, shell.nnod);	  /*TANGENTIAL MATRIX[Kt].*//*PROJECTION of einternal[Pt][Ht]{Fe}.*/
				//Kt = transformationIII(Kt, T, 6 * shell.nnod);
				//symmetricmtx(Kt, 6 * shell.nnod);      /*SYMMETRIC TANGENTIAL MATRIX[Ksym].*/
				//assemgstiffnessII(gmtx,Kt,&shell);
				//assemgstiffnessIIwithDOFelimination(gmtx, Kt, &shell, constraintmain);/*ASSEMBLAGE TANGENTIAL STIFFNESS MATRIX.*/
				freematrix(Kt, 18);

				ginternal = matrixvector(Tt, einternal, 6 * shell.nnod);  /*GLOBAL INTERNAL FORCE{Fg}.*/
				gpressure = matrixvector(Tt, epressure, 6 * shell.nnod);  /*GLOBAL EXTERNAL FORCE{Pg}.*/
				for (ii = 0; ii < shell.nnod; ii++)
				{
					for (jj = 0; jj < 6; jj++)
					{
						*(epsfinternal + *(loffset + (6 * ii + jj))) += *(ginternal + 6 * ii + jj);
						*(epsfpressure + *(loffset + (6 * ii + jj))) += *(gpressure + 6 * ii + jj);
					}
				}
				freematrix(drccosinit, 3);
				freematrix(drccos, 3);
				freematrix(T, 18);
				freematrix(Tt, 18);
				freematrix(Ke, 18);

				free(einternal);
				free(ginternal);
				free(epressure);
				free(gpressure);
				free(eform);
				free(gform);
				free(edisp);
				free(gdisp);
				free(loffset);
			}

			for (ii = 0; ii < msize; ii++)
			{
				if (*(constraintmain + ii) != ii)
				{
					*(epsfinternal + *(constraintmain + ii)) += *(epsfinternal + ii);
					*(epsfinternal + ii) = 0.0;
					*(epsfpressure + *(constraintmain + ii)) += *(epsfpressure + ii);
					*(epsfpressure + ii) = 0.0;
				}
			}
			for (ii = 0; ii < msize; ii++)
			{
				*(epsfunbalance + ii) = loadfactor * *(epsfpressure + ii) - *(epsfinternal + ii);
				if ((confs + ii)->iconf == 1) *(epsfunbalance + ii) = 0.0;
			}
			fprintf(fbcl, " %5.8e %5.8e \n", eps + gradeps, epsevctfunbalance);
			epsevctfunbalance = (dotproduct(evct, epsfunbalance, msize) - evctfunbalance) / gradeps;/*GRADIENT*/
			eps -= evctfunbalance / epsevctfunbalance;

			for (ii = 0; ii < msize; ii++)/*UPDATE FORM FOR DIRECTIONAL DERIVATIVE*/
			{
				*(ddisp + ii) = *(lastddisp + ii);
				*(gvct + ii) = eps * *(evct + ii);
			}
			for (ii = 0; ii < msize; ii++)/*FORMATION UPDATE FOR PREDICTOR/CORRECTOR*/
			{
				if (*(constraintmain + ii) != ii)
				{
					mainoff = *(constraintmain + ii);
					*(gvct + ii) = *(gvct + mainoff);
				}
			}
			updaterotation(ddisp, gvct, nnode);
			iteration++;

			/*if (abs(evctfunbalance) < 1e-8)
			{
				BCLFLAG = -2;
				nmode = 0;
			}*/
		}
		/*TERMINATION FLAG*/
		if (iteration == 1)
		{
			if (fnode != NULL && fnodedrc != NULL)
			{
				for (ii = 0; ii < nnode; ii++)
				{
					if ((nodes + ii)->code == fnode)
					{
						if (*(ddisp + 6 * ii + fnodedrc) - *(iform + 6 * ii + fnodedrc) < fnodemin || *(ddisp + 6 * ii + fnodedrc) - *(iform + 6 * ii + fnodedrc) > fnodemax)
						{
							ENDFLAG = 1;
							sprintf(string,"DEFORMATION EXCEED THRESHOLD(DEFORMATION = %e). ANALYSIS TERMINATED.\n", *(ddisp + 6 * ii + fnodedrc) - *(iform + 6 * ii + fnodedrc));
							errormessage(string);
						}
					}
				}
			}

		}
		/*GO TO NEXT LAP&ITERATION*/
		if (BCLFLAG==-1 && sign > 20)
		{
			ENDFLAG = 1;
			sprintf(string,"DIVERGENCE DITECTED(SIGN = %5ld). ANALYSIS TERMINATED.\n", sign);
			errormessage(string);
		}
		if (0/*nlap>20 && loadfactor < 0.0*/)
		{
			ENDFLAG = 1;
			sprintf(string,"NEGATIVE LOAD DITECTED(LOADFACTOR = %8.5f). ANALYSIS TERMINATED.\n", loadfactor);
			errormessage(string);
		}


		while(GetAsyncKeyState(VK_LBUTTON))  /*LEFT CLICK TO CONTINUE.*/
		{
		  if(GetAsyncKeyState(VK_RBUTTON))      /*RIGHT CLICK TO ABORT.*/
		  {
			gfree(gmtx, nnode);  /*FREE GLOBAL MATRIX.*/
			free(gvct);
			free(funbalance);
			free(finternal);
			free(fexternal);
			free(fpressure);
			free(due);
			free(dup);
			free(weight);

			if(fonl!=NULL) fprintf(fonl,"\nABORTED.\n");

			fclose(fin);
			fclose(fonl);
			fclose(fdsp);
			fclose(fexf);
			fclose(finf);
			fclose(fubf);
			fclose(fstr);
			fclose(fene);
			fclose(ffig);
			fclose(fbcl);

			laptime("\0",t0);
			return 1;
		  }
		  //t2=clock();
		  //time=(t2-t1)/CLK_TCK;
		  //if(time>=WAIT) break;               /*CONTINUE AFTER WAITING.*/
		}


	}

	fclose(fin);
	fclose(fonl);
	fclose(fdsp);
	fclose(fexf);
	fclose(finf);
	fclose(fubf);
	fclose(fstr);
	fclose(fene);
	fclose(ffig);
	fclose(fbcl);
	gfree(gmtx, nnode);  /*FREE GLOBAL MATRIX.*/
	errormessage(" ");
	errormessage("COMPLETED.");

	return 0;
}
/*arclmCR*/




double dotproduct(double* vct1, double* vct2, int vsize)
{
    int i;
	double dot;
	dot = 0.0;
	for (i = 0; i < vsize; i++) dot += (*(vct1 + i)) * (*(vct2 + i));
	return dot;
}/*dotproduct*/

double vectorlength(double* vct, int vsize)
{
    int i;
    double len;
    len = 0.0;
    for (i = 0; i < vsize; i++) len += (*(vct + i)) * (*(vct + i));
    len = sqrt(len);
    return len;
}/*vectorlength*/

void vectornormalize(double* vct, int vsize)
{
	int i;
    double len;
    len = vectorlength(vct,vsize);
    for (i = 0; i < vsize; i++) *(vct + i)/=len;
    return;
}/*vectorlength*/




double* rotationvct(double** rmtx)
{
	double c, s;
	double* rvct;
	double theta;
	rvct = (double*)malloc(3 * sizeof(double));
	c = *(*(rmtx + 0) + 0) + *(*(rmtx + 1) + 1) + *(*(rmtx + 2) + 2) - 1;                         /*2cos(theta)*/
	s = sqrt((*(*(rmtx + 2) + 1) - *(*(rmtx + 1) + 2)) * (*(*(rmtx + 2) + 1) - *(*(rmtx + 1) + 2))
		+ (*(*(rmtx + 0) + 2) - *(*(rmtx + 2) + 0)) * (*(*(rmtx + 0) + 2) - *(*(rmtx + 2) + 0))
		+ (*(*(rmtx + 1) + 0) - *(*(rmtx + 0) + 1)) * (*(*(rmtx + 1) + 0) - *(*(rmtx + 0) + 1)));  /*2sin(theta)>0*/

	if (s != 0.0)
	{
		if (c > 0.0)/*0<=theta<PI/2*/
		{
			theta = atan(s / c);
		}
		else if (c < 0.0)/*PI/2<theta<=PI*/
		{
			theta = atan(s / c) + PI;
		}
		else/*theta=PI/2*/
		{
			theta = PI / 2.0;
		}

		*(rvct + 0) = theta * ((*(*(rmtx + 2) + 1) - *(*(rmtx + 1) + 2))) / s;
		*(rvct + 1) = theta * ((*(*(rmtx + 0) + 2) - *(*(rmtx + 2) + 0))) / s;
		*(rvct + 2) = theta * ((*(*(rmtx + 1) + 0) - *(*(rmtx + 0) + 1))) / s;

	}
	else if (s == 0.0 && c > 0.0)/*theta=0*/
	{

		*(rvct + 0) = 0.0;
		*(rvct + 1) = 0.0;
		*(rvct + 2) = 0.0;

	}
	else if (s == 0.0 && c < 0.0)/*theta=PI*/
	{

		*(rvct + 0) = 0.5 * sqrt(*(*(rmtx + 0) + 0) + 1);
		if (*(rvct + 0) != 0)
		{
			*(rvct + 1) = 0.5 * *(*(rmtx + 0) + 1) / (*(rvct + 0));
			*(rvct + 2) = 0.5 * *(*(rmtx + 0) + 2) / (*(rvct + 0));
		}
		else
		{
			*(rvct + 1) = 0.5 * sqrt(*(*(rmtx + 1) + 1) + 1);
			if (*(rvct + 1) != 0)
			{
				*(rvct + 2) = 0.5 * *(*(rmtx + 1) + 2) / (*(rvct + 1));
			}
			else
			{
				*(rvct + 2) = 0.5 * sqrt(*(*(rmtx + 2) + 2) + 1);
			}
		}

	}
	return rvct;
}


double** rotationmtx(double* rvct)
{
	int i;
	double** rmtx;
	double* n;
	double theta;

	n = (double*)malloc(3 * sizeof(double));
	rmtx = (double**)malloc(3 * sizeof(double*));
	for (i = 0; i < 3; i++)
	{
		*(rmtx + i) = (double*)malloc(3 * sizeof(double));
	}
	theta = sqrt(*(rvct + 0) * *(rvct + 0) + *(rvct + 1) * *(rvct + 1) + *(rvct + 2) * *(rvct + 2));
	if (theta != 0.0)
	{
		for (i = 0; i < 3; i++)
		{
			*(n + i) = *(rvct + i) / theta;
		}

		*(*(rmtx + 0) + 0) = cos(theta) + (1 - cos(theta)) * *(n + 0) * *(n + 0);
		*(*(rmtx + 0) + 1) = -sin(theta) * *(n + 2) + (1 - cos(theta)) * *(n + 0) * *(n + 1);
		*(*(rmtx + 0) + 2) = sin(theta) * *(n + 1) + (1 - cos(theta)) * *(n + 0) * *(n + 2);
		*(*(rmtx + 1) + 0) = sin(theta) * *(n + 2) + (1 - cos(theta)) * *(n + 1) * *(n + 0);
		*(*(rmtx + 1) + 1) = cos(theta) + (1 - cos(theta)) * *(n + 1) * *(n + 1);
		*(*(rmtx + 1) + 2) = -sin(theta) * *(n + 0) + (1 - cos(theta)) * *(n + 1) * *(n + 2);
		*(*(rmtx + 2) + 0) = -sin(theta) * *(n + 1) + (1 - cos(theta)) * *(n + 2) * *(n + 0);
		*(*(rmtx + 2) + 1) = sin(theta) * *(n + 0) + (1 - cos(theta)) * *(n + 2) * *(n + 1);
		*(*(rmtx + 2) + 2) = cos(theta) + (1 - cos(theta)) * *(n + 2) * *(n + 2);
	}
	else
	{
		*(*(rmtx + 0) + 0) = 1.0;
		*(*(rmtx + 0) + 1) = 0.0;
		*(*(rmtx + 0) + 2) = 0.0;
		*(*(rmtx + 1) + 0) = 0.0;
		*(*(rmtx + 1) + 1) = 1.0;
		*(*(rmtx + 1) + 2) = 0.0;
		*(*(rmtx + 2) + 0) = 0.0;
		*(*(rmtx + 2) + 1) = 0.0;
		*(*(rmtx + 2) + 2) = 1.0;
	}
	free(n);
	return rmtx;
}

double** spinmtx(double* rvct)
{
	int i;
	double** smtx;

	smtx = (double**)malloc(3 * sizeof(double*));
	for (i = 0; i < 3; i++)
	{
		*(smtx + i) = (double*)malloc(3 * sizeof(double));
	}

	*(*(smtx + 0) + 0) = 0.0;
	*(*(smtx + 0) + 1) = -*(rvct + 2);
	*(*(smtx + 0) + 2) = *(rvct + 1);
	*(*(smtx + 1) + 0) = *(rvct + 2);
	*(*(smtx + 1) + 1) = 0.0;
	*(*(smtx + 1) + 2) = -*(rvct + 0);
	*(*(smtx + 2) + 0) = -*(rvct + 1);
	*(*(smtx + 2) + 1) = *(rvct + 0);
	*(*(smtx + 2) + 2) = 0.0;

	return smtx;
}

double** jacobimtx(double* rvct)
/*transformation from additional infinitesimal incremental rotation to increment of total rotational pseudo-vector*/
{
	int n, i, j;
	double theta, eta;
	double** thetaspin, ** thetaspin2;
	double** H;


	H = (double**)malloc(3 * sizeof(double*));
	for (i = 0; i < 3; i++)
	{
		*(H + i) = (double*)malloc(3 * sizeof(double));
		for (j = 0; j < 3; j++)
		{
			*(*(H + i) + j) = 0.0;
		}
	}

	theta = vectorlength(rvct,3);

	if (theta < PI / 30.0)
	{
		eta = 1.0 / 12.0 + pow(theta, 2) / 720.0 + pow(theta, 4) / 30240.0 + pow(theta, 6) / 1209600.0;
	}
	else
	{
		eta = (1.0 - 0.5 * theta * (1.0 / tan(0.5 * theta))) / pow(theta, 2);
	}
	thetaspin = spinmtx(rvct);
	thetaspin2 = matrixmatrix(thetaspin, thetaspin, 3);


	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			*(*(H + i) + j) = -0.5 * *(*(thetaspin + i) + j) + eta * *(*(thetaspin2 + i) + j);
			if (i == j)*(*(H + i) + j) += 1.0;
		}
	}
	freematrix(thetaspin, 3);
	freematrix(thetaspin2, 3);
	return H;
}


double** spinfittermtx(double* eform, int nnod)
/*spin-fitter matrix for beam & shell*/
/*G     :3*6nnod matrix(rotational variation by translational motion)*/
/*input :6nnod vector(variation of nodal displacement in local which inclouds noneffective rotational DOF)*/
/*output:3 vector(variation of local coord psuedo rotation)*/
{
	int i, j;
	double A, len;
	double x1, x2, y1, y2, z1;
	double** G;


	G = (double**)malloc(3 * sizeof(double*));
	for (i = 0; i < 3; i++)
	{
		*(G + i) = (double*)malloc(6*nnod * sizeof(double));
		for (j = 0; j < 6*nnod; j++)
		{
			*(*(G + i) + j) = 0.0;
		}
	}


	if(nnod==2)/*[G1,0,G2,0]*/
	{

		x1 = *(eform + 6) - *(eform + 0);
		y1 = *(eform + 7) - *(eform + 1);
		z1 = *(eform + 8) - *(eform + 2);
		len = sqrt(x1 * x1 + y1 * y1 + z1 * z1);

		/*G1*/
		*(*(G + 1) + 2) =  1 / len;
		*(*(G + 2) + 1) = -1 / len;
		/*G2*/
		*(*(G + 1) + 8) = -1 / len;
		*(*(G + 2) + 7) =  1 / len;
	}
	if(nnod==3)/*[G1,0,G2,0,G3,0]*/
	{

		x1 = *(eform + 6) - *(eform + 0);
		y1 = *(eform + 7) - *(eform + 1);
		x2 = *(eform + 12) - *(eform + 0);
		y2 = *(eform + 13) - *(eform + 1);
		A = 0.5 * (x1 * y2 - x2 * y1);
		len = sqrt(x1 * x1 + y1 * y1);

		/*G1*/
		*(*(G + 0) + 2) = 0.5 * (*(eform + 12) - *(eform + 6)) / A;
		*(*(G + 1) + 2) = 0.5 * (*(eform + 13) - *(eform + 7)) / A;
		*(*(G + 2) + 1) = -1 / len;
		/*G2*/
		*(*(G + 0) + 8) = 0.5 * (*(eform + 0) - *(eform + 12)) / A;
		*(*(G + 1) + 8) = 0.5 * (*(eform + 1) - *(eform + 13)) / A;
		*(*(G + 2) + 7) = 1 / len;
		/*G3*/
		*(*(G + 0) + 14) = 0.5 * (*(eform + 6) - *(eform + 0)) / A;
		*(*(G + 1) + 14) = 0.5 * (*(eform + 7) - *(eform + 1)) / A;
	}
	return G;
}

double** projectionmtx(double* eform, double* edisp, double** G,int nnod)
/*element projection matrix for beam & shell*/
/*G     :6nnod*6nnod matrix(variation correction)*/
/*input :6nnod vector(initial variation of displacement in local coord)*/
/*output:6nnod vector(corrected variation of displacement in local coord)*/
{
	int i, j, a, b;
	double* node;
	double** P, ** Gu, ** S, ** SGu;

	P = (double**)malloc(6*nnod * sizeof(double*));
	for (i = 0; i < 6*nnod; i++)
	{
		*(P + i) = (double*)malloc(6*nnod * sizeof(double));
	}

	/*latest coordination of nodes in local*/
	/*eform(initial coord)+edisp(displacement)*/
	node = (double*)malloc(3 * sizeof(double));

	/*for extracting Gu_b(b=1,2,3) from G*/
	Gu = (double**)malloc(3 * sizeof(double*));
	for (i = 0; i < 3; i++)
	{
		*(Gu + i) = (double*)malloc(3 * sizeof(double));
	}
	//Pab = [ delta*I-1/3*I+S_a*Gu_b    0       ]
	//      [         -Gu_b             delta*I ]

	for (a = 0; a < nnod; a++)/*row 6*a+0~6*a+5 of P*/
	{
		for (i = 0; i < 3; i++)
		{
			*(node + i) = *(eform + 6 * a + i) + *(edisp + 6 * a + i);
		}
		S = spinmtx(node);
		for (b = 0; b < nnod; b++)/*column 6*b+0~6*b+5 of P*/
		{
			for (i = 0; i < 3; i++)
			{
				for (j = 0; j < 3; j++)
				{
					*(*(Gu + i) + j) = *(*(G + i) + 6 * b + j);
				}
			}
			SGu = matrixmatrix(S, Gu, 3);
			for (i = 0; i < 3; i++)
			{
				for (j = 0; j < 3; j++)
				{
					*(*(P + 6 * a + 3 + i) + 6 * b + j) = -*(*(Gu + i) + j);/*-Gu_b*/
					*(*(P + 6 * a + i) + 6 * b + 3 + j) = 0.0;				/*0*/
					if (a == b && i == j)
					{
						*(*(P + 6 * a + i) + 6 * b + j) = 1.0 - 1.0/(double)nnod;	/*delta*I-1/3*I*/
						*(*(P + 6 * a + 3 + i) + 6 * b + 3 + j) = 1.0;		/*delta*I*/
					}
					else if (i == j)
					{
						*(*(P + 6 * a + i) + 6 * b + j) = - 1.0/(double)nnod;		/*delta*I-1/3*I*/
						*(*(P + 6 * a + 3 + i) + 6 * b + 3 + j) = 0.0;		/*delta*I*/
					}
					else
					{
						*(*(P + 6 * a + i) + 6 * b + j) = 0.0;				/*delta*I-1/3*I*/
						*(*(P + 6 * a + 3 + i) + 6 * b + 3 + j) = 0.0;		/*delta*I*/
					}
					*(*(P + 6 * a + i) + 6 * b + j) += *(*(SGu + i) + j);	/*S_a*Gu_b*/
				}
			}
			freematrix(SGu, 3);
		}
		freematrix(S, 3);
	}
	free(node);
	freematrix(Gu, 3);
	return P;
}

double** blockjacobimtx(double* edisp, double* estress, double** M, int nnod)
{
	int n, i, j;
	double theta, dot, eta, mu;
	double* rvct, * mvct;
	double** thetaspin, ** thetaspin2, ** mspin, ** mtheta, ** mtheta2;
	double** H, ** Ha, ** Ma;

	/*H=diag[I, H_1, I, H_2(, I, H_3)]*/
	H = (double**)malloc(6*nnod * sizeof(double*));
	for (i = 0; i < 6*nnod; i++)
	{
		*(H + i) = (double*)malloc(6*nnod * sizeof(double));
		for (j = 0; j < 6*nnod; j++)
		{
			*(*(H + i) + j) = 0.0;
		}
	}

	mtheta = (double**)malloc(3 * sizeof(double*));                    /*{ma}{ƒÆat}*/
	for (i = 0; i < 3; i++)
	{
		*(mtheta + i) = (double*)malloc(3 * sizeof(double));
	}

	rvct = (double*)malloc(3 * sizeof(double));
	mvct = (double*)malloc(3 * sizeof(double));

	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 3; i++)
		{
			*(rvct + i) = *(edisp + 6 * n + 3 + i);
			*(mvct + i) = *(estress + 6 * n + 3 + i);
		}
		theta = vectorlength(rvct,3);
		dot = dotproduct(rvct,mvct,3);

		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				*(*(mtheta + i) + j) = *(mvct + i) * *(rvct + j);
			}
		}

		if (theta < PI / 30.0)
		{
			eta = 1.0 / 12.0 + pow(theta, 2) / 720.0 + pow(theta, 4) / 30240.0 + pow(theta, 6) / 1209600.0;
			mu = 1.0 / 360.0 + pow(theta, 2) / 7560.0 + pow(theta, 4) / 201600.0 + pow(theta, 6) / 5987520.0;
		}
		else
		{
			eta = (1.0 - 0.5 * theta * (1.0 / tan(0.5 * theta))) / pow(theta, 2);
			mu = (theta * theta + 4.0 * cos(theta) + theta * sin(theta) - 4.0)
				/ (4.0 * pow(theta, 4) * sin(0.5 * theta) * sin(0.5 * theta));
		}
		thetaspin = spinmtx(rvct);
		thetaspin2 = matrixmatrix(thetaspin, thetaspin, 3);

		mspin = spinmtx(mvct);
		mtheta2 = matrixmatrix(thetaspin2, mtheta, 3);
		Ha = (double**)malloc(3 * sizeof(double*));
		for (i = 0; i < 3; i++)
		{
			*(Ha + i) = (double*)malloc(3 * sizeof(double));
		}
		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				*(*(Ha + i) + j) = -0.5 * *(*(thetaspin + i) + j) + eta * *(*(thetaspin2 + i) + j);
				if (i == j)*(*(Ha + i) + j) += 1.0;

				*(*(mtheta2 + i) + j) *= mu;
				*(*(mtheta2 + i) + j) += eta * ( *(*(mtheta + j) + i) - 2.0 * *(*(mtheta + i) + j) ) - 0.5 * *(*(mspin + i) + j);
				if (i == j)*(*(mtheta2 + i) + j) += eta * dot;
			}
		}

		Ma = matrixmatrix(mtheta2, Ha, 3);

		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				*(*(H + 6 * n + 3 + i) + 6 * n + 3 + j) = *(*(Ha + i) + j);
				*(*(M + 6 * n + 3 + i) + 6 * n + 3 + j) = *(*(Ma + i) + j);
				if (i == j)*(*(H + 6 * n + i) + 6 * n + j) = 1.0;
			}
		}
		freematrix(thetaspin, 3);
		freematrix(thetaspin2, 3);
		freematrix(mspin, 3);
		freematrix(mtheta2, 3);
		freematrix(Ma, 3);
		freematrix(Ha, 3);
	}
	free(rvct);
	free(mvct);
	freematrix(mtheta, 3);
	return H;
}

double** assemtmtx(double** estiff, double* eform, double* edisp, double* estress, double** T, int nnod)
{
	int i, j, n;
	double** G, ** P, ** H;
	double** HP, ** PtHt;
	double* nm, ** spinnm, * pstress;
	double** Fnm, ** Fn, ** FnG, ** GtFnt;
	double** tstiff, ** gstiff1, ** gstiff2, ** gstiff3;


	tstiff = (double**)malloc(6*nnod * sizeof(double*));                              /*[Kr]*/
	for (i = 0; i < 6*nnod; i++)
	{
		*(tstiff + i) = (double*)malloc(6*nnod * sizeof(double));
	}

	gstiff3 = (double**)malloc(6*nnod * sizeof(double*));                              /*[M]*/
	for (i = 0; i < 6*nnod; i++)
	{
		*(gstiff3 + i) = (double*)malloc(6*nnod * sizeof(double));
		for (j = 0; j < 6*nnod; j++)
		{
			*(*(gstiff3 + i) + j) = 0.0;
		}
	}


	G = spinfittermtx(eform, nnod);                     /*SPIN-FITTER MATRIX[G].*/
	P = projectionmtx(eform, edisp, G, nnod);    		/*PROJECTION MATRIX[P].*/
	H = blockjacobimtx(edisp, estress, gstiff3, nnod);  /*JACOBIAN MATRIX OF ROTATION[H].*/
	HP = matrixmatrix(H, P, 6*nnod);                    /*[H][P]*/
	PtHt = matrixtranspose(HP, 6*nnod);
	pstress = matrixvector(PtHt, estress, 6*nnod);      /*projected estress {Fp}*/
	for (i = 0; i < 6*nnod; i++)
	{
		*(estress + i) = *(pstress + i);
	}
	free(pstress);

	nm = (double*)malloc(3 * sizeof(double));           /*projected estress of each node {n}&{m}*/

	Fnm = (double**)malloc(6*nnod * sizeof(double*));                          /*[Fnm]*/
	for (i = 0; i < 6*nnod; i++)
	{
		*(Fnm + i) = (double*)malloc(3 * sizeof(double));
	}
	Fn = (double**)malloc(6*nnod * sizeof(double*));                            /*[Fn]*/
	for (i = 0; i < 6*nnod; i++)
	{
		*(Fn + i) = (double*)malloc(3 * sizeof(double));
	}

	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 3; i++)
		{
			*(nm + i) = *(estress + 6 * n + i);
		}
		spinnm = spinmtx(nm);
		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				*(*(Fnm + 6 * n + i) + j) = *(*(spinnm + i) + j);
				*(*(Fn + 6 * n + i) + j) = *(*(spinnm + i) + j);
			}
		}
		freematrix(spinnm, 3);

		for (i = 0; i < 3; i++)
		{
			*(nm + i) = *(estress + 6 * n + 3 + i);
		}
		spinnm = spinmtx(nm);
		for (i = 0; i < 3; i++)
		{
			for (j = 0; j < 3; j++)
			{
				*(*(Fnm + 6 * n + 3 + i) + j) = *(*(spinnm + i) + j);
				*(*(Fn + 6 * n + 3 + i) + j) = 0.0;
			}
		}
		freematrix(spinnm, 3);
	}


	estiff = transformationIII(estiff, HP, 6*nnod);			/*[Pt][Ht][K][H][P]*/

	gstiff1 = matrixmatrixIII(Fnm, G, 6*nnod, 3, 6*nnod);		/*[Fnm][G]*/

	FnG = matrixmatrixIII(Fn, G, 6*nnod, 3, 6*nnod);         	/*[Fn][G]*/
	GtFnt = matrixtranspose(FnG, 6*nnod);                   /*[Gt][Fnt]*/
	gstiff2 = matrixmatrix(GtFnt, P, 6*nnod);               /*[Gt][Fnt][P]*/

	gstiff3 = transformationIII(gstiff3, P, 6*nnod);        /*[Pt][M][P]*/

	for (i = 0; i < 6*nnod; i++)
	{
		for (j = 0; j < 6*nnod; j++)
		{
			*(*(tstiff + i) + j) = *(*(estiff + i) + j) - *(*(gstiff1 + i) + j) - *(*(gstiff2 + i) + j) + *(*(gstiff3 + i) + j);
		}
	}


	free(nm);

	freematrix(G, 3);
	freematrix(P, 6*nnod);
	freematrix(H, 6*nnod);
	freematrix(PtHt, 6*nnod);
	freematrix(HP, 6*nnod);
	freematrix(Fnm, 6*nnod);
	freematrix(Fn, 6*nnod);

	freematrix(gstiff1, 6*nnod);
	freematrix(FnG, 6*nnod);
	freematrix(GtFnt, 6*nnod);
	freematrix(gstiff2, 6*nnod);
	freematrix(gstiff3, 6*nnod);
	return tstiff;
}

void symmetricmtx(double** estiff, int msize)
{
	int i, j;
	for (i = 0; i < msize; i++)
	{
		for (j = 0; j < i; j++)
		{
			*(*(estiff + i) + j) = 0.5 * (*(*(estiff + i) + j) + *(*(estiff + j) + i));
			*(*(estiff + j) + i) = *(*(estiff + i) + j);
		}
	}
	return;
}

void updaterotation(double* ddisp, double* gvct, int nnode)
/*FORMATION UPDATE IF ROTATION IS FINITE.*/
{
	int i, j;
	long int loff;
	double* rvctR, * rvctL, * rvct;
	double** rmtxR, ** rmtxL, ** rmtx;
	rvctR = (double*)malloc(3 * sizeof(double));
	rvctL = (double*)malloc(3 * sizeof(double));
	for (i = 0; i < nnode; i++)
	{
		for (j = 0; j < 3; j++)
		{
			loff = 6 * i + j;
			*(ddisp + loff) += *(gvct + loff);
		}
		for (j = 0; j < 3; j++)
		{
			loff = 6 * i + 3 + j;
			*(rvctR + j) = *(ddisp + loff);
			*(rvctL + j) = *(gvct + loff);
		}
		rmtxR = rotationmtx(rvctR);
		rmtxL = rotationmtx(rvctL);
		rmtx = matrixmatrix(rmtxL, rmtxR, 3);
		rvct = rotationvct(rmtx);
		for (j = 0; j < 3; j++)
		{
			loff = 6 * i + 3 + j;
			*(ddisp + loff) = *(rvct + j);
		}
		freematrix(rmtxR, 3);
		freematrix(rmtxL, 3);
		freematrix(rmtx, 3);
		free(rvct);
	}
	free(rvctR);
	free(rvctL);
	return;
}/*updaterotation*/


double** updatedrccos(double** drccosinit, double* gdisp)
{
	int i;
	double** drccos;
	double* rvct1, * rvct2, *rvct;
	double** rmtx1, ** rmtx2, **trmtx1, ** rmtx;
	double** alpharmtx, **midrmtx;

	rvct1 = (double*)malloc(3 * sizeof(double));
	rvct2 = (double*)malloc(3 * sizeof(double));

	for (i = 0; i < 3; i++)
	{
		*(rvct1 + i) += *(gdisp + 3 + i);
		*(rvct2 + i) += *(gdisp + 9 + i);
	}

	rmtx1 = rotationmtx(rvct1);
	rmtx2 = rotationmtx(rvct2);
	trmtx1 = matrixtranspose(rmtx1,3);
	rmtx = matrixmatrix(rmtx2, trmtx1, 3);
	rvct = rotationvct(rmtx);

	for (i = 0; i < 3; i++)
	{
		*(rvct+i)*=0.5;
	}

	alpharmtx = rotationmtx(rvct);
	midrmtx = matrixmatrix(alpharmtx, rmtx1, 3);
	drccos = matrixmatrix(midrmtx, drccosinit, 3);


	freematrix(rmtx1, 3);
	freematrix(rmtx2, 3);
	freematrix(trmtx1, 3);
	freematrix(rmtx, 3);
	freematrix(alpharmtx, 3);
	freematrix(midrmtx, 3);
	free(rvct1);
	free(rvct2);

	return drccos;
}

/*
double** interpolaterotation(double* rvct1, double* rvct2, double alpha)
{
	int i, j;
	long int loff;
	double* rvct;
	double** rmtx1, ** rmtx2, **trmtx1, ** rmtx;

	rmtx1 = rotationmtx(rvct1);
	rmtx2 = rotationmtx(rvct2);
	trmtx1 = matrixtranspose(rmtx1);
	rmtx = matrixmatrix(rmtx2, trmtx1, 3);
	rvct = rotationvct(rmtx);

	for (i = 0; i < 3; i++)
	{
		*(rvct+i)*=alpha;
	}

	alpharmtx = rotationmtx(rvct);
	midrmtx = matrixmatrix(alpharmtx, rmtx1, 3);


	freematrix(rmtx1, 3);
	freematrix(rmtx2, 3);
	freematrix(trmtx1, 3);
	freematrix(rmtx, 3);
	free(rvct);

	return midrmtx;
}*/
/*interpolaterotation*/


/*
void updateforce(double* pvct, double* ddisp, int nnode)
{
	int i, j;
	long int loff;
	double* rvctR, * rvctL, * rvct;
	double** rmtxR, ** rmtxL, ** rmtx;
	rvctR = (double*)malloc(3 * nnode * sizeof(double));
	rvctL = (double*)malloc(3 * nnode * sizeof(double));
	for (i = 0; i < nnode; i++)
	{
		for (j = 0; j < 3; j++)
		{
			loff = 6 * i + j;
			*(rvctR + j) = *(pvct + loff);
			*(rvctL + j) = *(ddisp + loff + 3);
		}
		rmtxR = rotationmtx(rvctR);
		rmtxL = rotationmtx(rvctL);
		rmtx = matrixmatrix(rmtxL, rmtxR, 3);
		rvct = rotationvct(rmtx);
		for (j = 0; j < 3; j++)
		{
			loff = 6 * i + j;
			*(pvct + loff) = *(rvct + j);
		}
		freematrix(rmtxR, 3);
		freematrix(rmtxL, 3);
		freematrix(rmtx, 3);
		free(rvct);
	}
	free(rvctR);
	free(rvctL);
	return;
}
*/
/*updateforce*/


double* extractlocalcoord(double* gdisp, double** drccos, double nnod)
/*EXTRACT LOCAL ELEMENT DEFORMATION FROM GLOBAL.*/
/*UPDATE PSUEDO-ROTATION VECTOR*/
{
	long int i, n;
	double* d, * r, * c, * td, * tr, * edisp;
	double** trmtx, ** rmtx;

	edisp = (double*)malloc(6 * nnod * sizeof(double));

	c = (double*)malloc(3 * sizeof(double));
	d = (double*)malloc(3 * sizeof(double));
	r = (double*)malloc(3 * sizeof(double));

	for (i = 0; i < 3; i++)
	{
		*(c + i) = 0.0;
		for (n = 0; n < nnod; n++)
		{
			*(c + i) += *(gdisp + 6 * n + i) / nnod;
		}
	}
	/*CENTER*/
	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 3; i++)
		{
			*(d + i) = *(gdisp + 6 * n + i) - *(c + i);
			*(r + i) = *(gdisp + 6 * n + 3 + i);
		}

		td = matrixvector(drccos, d, 3);
		/*EACH NODE FROM CENTER*/

		rmtx = rotationmtx(r);
		/*rmtx:Ra*/
		trmtx = matrixmatrix(drccos, rmtx, 3);/*TRIAD DIRECTION MATRIX(3 VECTOR) IN LOCAL*/
		tr = rotationvct(trmtx);

		for (i = 0; i < 3; i++)
		{
			*(edisp + 6 * n + i) = *(td + i);
			*(edisp + 6 * n + 3 + i) = *(tr + i);
		}
		free(td);
		free(tr);
		freematrix(rmtx, 3);
		freematrix(trmtx, 3);
	}
	free(c);
	free(d);
	free(r);

	return edisp;
}/*extractlocalcoord*/


double* extractshelldisplacement(struct oshell shell, double* ddisp)
/*EXTRACT ELEMENT DEFORMATION{dU} FROM GLOBAL VECTOR.*/
{
	long int i, loffset;
	int n, nnod;
	double* d;

	nnod = shell.nnod;
	d = (double*)malloc(6 * nnod * sizeof(double));
	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 6; i++)
		{
			loffset = 6 * (shell.node[n]->loff) + i;
			*(d + 6 * n + i) = *(ddisp + loffset);
		}
	}
	return d;
}/*extractshelldisplacement*/


/*USE NEW VERSION "extractlocalcoord".*/
#if 0
double* extractshelllocalcoord(struct oshell shell, double* gdisp)
/*EXTRACT LOCAL ELEMENT DEFORMATION FROM GLOBAL.*/
/*UPDATE PSUEDO-ROTATION VECTOR*/
{
	long int i, loffset;
	int n, nnod;
	double* d, * r, * c, * td, * tr, * edisp;
	double** drccos, ** trmtx, ** rmtx;

	nnod = shell.nnod;

	edisp = (double*)malloc(6 * nnod * sizeof(double));

	c = (double*)malloc(3 * sizeof(double));
	d = (double*)malloc(3 * sizeof(double));
	r = (double*)malloc(3 * sizeof(double));

	drccos = shelldrccos(shell, NULL);

	for (i = 0; i < 3; i++)
	{
		*(c + i) = 0.0;
		for (n = 0; n < nnod; n++)
		{
			*(c + i) += *(gdisp + 6 * n + i) / nnod;
		}
	}
	/*CENTER*/
	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 3; i++)
		{
			*(d + i) = *(gdisp + 6 * n + i) - *(c + i);
			*(r + i) = *(gdisp + 6 * n + 3 + i);
		}

		td = matrixvector(drccos, d, 3);
		/*EACH NODE FROM CENTER*/

		rmtx = rotationmtx(r);
		/*rmtx:Ra*/
		trmtx = matrixmatrix(drccos, rmtx, 3);/*TRIAD DIRECTION MATRIX(3 VECTOR) IN LOCAL*/
		tr = rotationvct(trmtx);

		for (i = 0; i < 3; i++)
		{
			*(edisp + 6 * n + i) = *(td + i);
			*(edisp + 6 * n + 3 + i) = *(tr + i);
		}
		free(td);
		free(tr);
		freematrix(rmtx, 3);
		freematrix(trmtx, 3);
	}


	free(c);
	free(d);
	free(r);
	freematrix(drccos, 3);

	return edisp;
}/*extractshelllocalcoord*/
#endif

void extractdeformation(double* eform, double* edisp, int nnod)
/*EXTRACT LOCAL ELEMENT DEFORMATION FROM GLOBAL.*/
/*UPDATE PSUEDO-ROTATION VECTOR*/
{
	int n, i;
	double* r, * rinit, * rvct;
	double** rmtx, ** rh, ** rt, ** rtt;

	r = (double*)malloc(3 * sizeof(double));
	rinit = (double*)malloc(3 * sizeof(double));

	for (n = 0; n < nnod; n++)
	{
		for (i = 0; i < 3; i++)
		{
			*(r + i) = *(edisp + 6 * n + 3 + i);
			*(rinit + i) = *(eform + 6 * n + 3 + i);
		}

		rh = rotationmtx(r);
		rt = rotationmtx(rinit);
		rtt = matrixtranspose(rt, 3);
		rmtx = matrixmatrix(rh, rtt, 3);
		rvct = rotationvct(rmtx);

		for (i = 0; i < 3; i++)
		{
			*(edisp + 6 * n + i) -= *(eform + 6 * n + i);
			*(edisp + 6 * n + 3 + i) = *(rvct + i);
		}

		freematrix(rh, 3);
		freematrix(rt, 3);
		freematrix(rtt, 3);
		freematrix(rmtx, 3);
		free(rvct);
	}

	free(r);
	free(rinit);
	return;
}

void initialformCR(struct onode* nodes, double* ddisp, int nnode)
/*INITIAL FORMATION INTO DISPLACEMENT.WITHOUT NODE CODE.*/
{
	int i, j;

	for (i = 0; i < nnode; i++)
	{
		for (j = 0; j < 3; j++)
		{
			*(ddisp + 6 * i + j) = (nodes + i)->d[j];
			if ((nodes + i)->r[j] != NULL)
			{
				*(ddisp + 6 * i + 3 + j) = (nodes + i)->r[j];
			}
			else
			{
				*(ddisp + 6 * i + 3 + j) = 0.01;
			}
		}
	}


	return;
}/*initialformCR*/

void LDLmode(struct gcomponent* gmtx, struct oconf* confs, long int*  m, int nmode, double** mode, double* norm, double* dm, long int msize)
{
	double data;
	double LDLnorm;
	struct gcomponent* gcomp1;
	long int i, j, k;
	long int ii;
	for (i = 0; i < nmode; i++)
	{
		ii = *( m + i);
		*(dm + i) = (gmtx + ii)->value;
		LDLnorm = 0.0;
		for (j = msize - 1; j >= 0; j--)                                 /*BACKWARD.*/
		{
			if (j == ii)
			{
				*(*(mode + i) + j) = 1.0;
			}
			else
			{
				*(*(mode + i) + j) = 0.0;
			}

			if ((confs + j)->iconf == 0)
			{
				data = *(*(mode + i) + j);
				gcomp1 = (gmtx + j); /*DIAGONAL.*/
				while (gcomp1->down != NULL) /*DOWNWARD.*/
				{
					gcomp1 = gcomp1->down;
					k = gcomp1->m;
					if ((confs + k - 1)->iconf == 0) /*FREE*/
					{
						data -= (gcomp1->value) * (*(*(mode + i) + k - 1));
					}
				}
				*(*(mode + i) + j) = data;
				LDLnorm += data * data;
			}
		}
		*(norm + i) = sqrt(LDLnorm);
		for (j = 0; j < msize; j++)                                 /*BACKWARD.*/
		{
			*(*(mode + i) + j) /= *(norm + i);
		}

	}
	return;
}

double shellvolume(struct oshell shell, double** drccos, double area)
{
	double volume;
	struct onode node = *(shell.node[0]);

	volume = (*(*(drccos + 2) + 0) * node.d[GX]
		+ *(*(drccos + 2) + 1) * node.d[GY]
		+ *(*(drccos + 2) + 2) * node.d[GZ]) * area / 3.0;
	return volume;
}/*shellvolume*/

/*
double equilibriumcurvature(double* weight, double* ddisp, double* lastddisp, double loadfactor, double lastloadfactor, double* dup, int msize)
{
	int i;
	double* vct, * lastvct;
	double cos, dot, len, lastlen, curvature;
	char string[40];
	vct = (double*)malloc(msize * sizeof(double));
	lastvct = (double*)malloc(msize * sizeof(double));
	dot = loadfactor - lastloadfactor;
	len = 1.0;
	lastlen = (loadfactor - lastloadfactor) * (loadfactor - lastloadfactor);
	for (i = 0; i < msize; i++)
	{
		*(vct + i) = *(weight + i) * *(dup + i);
		*(lastvct + i) = *(weight + i) * (*(ddisp + i) - *(lastddisp + i));
		dot += *(vct + i) * *(lastvct + i);
		len += *(vct + i) * *(vct + i);
		lastlen += *(lastvct + i) * *(lastvct + i);
	}
	cos = abs(dot / sqrt(len * lastlen));
	curvature = acos(cos) / sqrt(lastlen);
	free(vct);
	free(lastvct);
	return curvature;
}
*/

double equilibriumcurvature(double* weight, double* lapddisp, double laploadfactor, double* dup, int msize)
{
	int i;
	double cos, dot, len, lastlen, curvature;
	char string[40];

	dot = laploadfactor;
	len = 1.0;
	lastlen = laploadfactor * laploadfactor;
	for (i = 0; i < msize; i++)
	{
		dot += *(weight + i) **(dup + i) **(weight + i) **(lapddisp + i);
		len += *(weight + i) **(dup + i) **(weight + i) **(dup + i);
		lastlen += *(weight + i) **(lapddisp + i) **(weight + i) **(lapddisp + i);
	}
	cos = abs(dot / sqrt(len * lastlen));
	curvature = acos(cos) / sqrt(lastlen);
	return curvature;
}